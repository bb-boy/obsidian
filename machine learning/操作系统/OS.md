## **BIOS
### 1. **BIOS的作用和存放位置**

- **作用**：BIOS（Basic Input/Output System）是计算机加电后运行的第一段程序，负责**硬件的自检和初始化**，以及后续操作系统引导的准备工作。
- **存放位置**：BIOS固化在**主板上的ROM芯片**里。ROM（只读存储器）断电后数据不会丢失，非常适合存储“启动时必须有”的程序代码。

---

### 2. **BIOS的入口和实模式寻址**

- **入口地址**：CPU复位后，会自动跳到物理地址`0xFFFF0`处执行BIOS（其实这只是BIOS映像的末尾，实际只放一个跳转指令）。
- **CS:IP寻址机制**：实模式下，CS:IP（代码段:指令指针）组合起来可以寻址20位物理地址，即`(CS << 4) + IP`。例如启动时CS=0xF000, IP=0xFFF0，最终地址就是`0xFFFF0`。
- **跳转原理**：`0xFFFF0`只存了一个“跳转指令”，实际BIOS代码在别处，比如`0xFE05B`。

---

### 3. **BIOS初始化及中断向量表**

- BIOS会对**内存、显卡、键盘等外设做自检**和初始化，还要给后续系统引导做准备。
- BIOS最重要的工作之一：**建立中断向量表（Interrupt Vector Table, IVT）**。
    - 位置：实模式下，**中断向量表位于内存0x0000 ~ 0x03FF**（即前1KB空间）。
    - 作用：存放256个中断类型（0~255，每个4字节），每个中断的入口地址，也就是“向量”。
    - 这样，CPU遇到`int xx`指令（如`int 0x80`），就能从IVT查到处理该中断的函数地址，快速跳转过去执行对应服务。

---

### 4. **BIOS到MBR的流程梳理**

- BIOS初始化硬件
- 建立中断向量表
- 加载并跳转到**MBR（主引导记录）**，为操作系统启动做准备

---
## **BIOS的最后一项任务**

- **检测磁盘**：BIOS会去检查“0盘0道1扇区”（即第一个硬盘的第一个柱面、第一扇区）内容。
- **历史原因**：扇区编号从1开始，所以“1扇区”其实是第一个扇区，不用纠结。

## 2. **MBR的“魔数”检测**

- **魔数**：BIOS会检查这个扇区最后两个字节（第511字节和第512字节）。
    - 必须分别为`0x55`和`0xAA`（小端序存储，其实在内存中是`0xAA55`）。
- **作用**：这是一种“标记”，告诉BIOS“这是一个有效的启动扇区（可引导扇区）”。

## 3. **MBR的加载位置和执行**

- **加载位置**：如果检测到魔数，BIOS会把整个512字节的MBR代码加载到**内存的物理地址0x7C00**处。
- **跳转执行**：接着CPU会跳转到0x7C00，开始执行MBR里的引导程序（这也是我们写自制操作系统时第一个能“跑起来”的自己的代码）。

## 4. **MBR相关规定**

- **大小**：MBR固定为**512字节**。
- **末尾魔数**：第511字节和第512字节必须是`0xAA`、`0x55`（用小端序存储，实际为`0x55AA`）。
- **内容**：前446字节通常存放引导程序代码，接着64字节是分区表，最后2字节是魔数。
- **小端序**：因为x86平台是小端序，所以存储顺序是低字节在前（即`0x55`，再是`0xAA`）。

![[image.png]]![[Pasted image 20250828145854.png]]

## 保护模式入门
开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

---

根据您提供的信息，这是一个关于 **全局描述符表 (GDT)** 的描述，可以总结如下：

---


### 全局描述符表 (Global Descriptor Table, GDT)

- **本质**: 全局描述符表是一个储存在内存中的“表”，它由一系列被称为 **段描述符** 的表项组成。
    
- **表项 (段描述符)**: 表中的每一个条目都称为一个段描述符，其大小为 **64 字节**。每个段描述符都用来详细描述一个内存段，包括它的**起始地址**、**大小**和**访问权限**等信息。
    
- **存放位置与引用**: 由于该表可能非常大，因此它被存放在内存中。处理器使用 **GDTR 寄存器** 来指向该表的起始位置，从而能够找到并访问它。
    

简而言之，全局描述符表就像一个目录，列出了所有可用的内存段，而 GDTR 寄存器则像一个指针，指向这个目录的起点，让处理器可以快速找到它。

---

### 1. 从实模式到保护模式的转变

在实模式下，CPU（如 8086）直接使用**段基址**和**偏移地址**计算出物理地址。

- **实模式（16 位）**：
    
    - 段寄存器中存放的是**段基址**。
        
    - 物理地址 = **段基址**左移 4 位 + **偏移地址**。
        
    - 每次访问都需进行计算，效率较低。
        

在保护模式下，为了增强安全性和灵活性，段寄存器不再直接存储段基址。

- **保护模式（32 位及以上）**：
    
    - 段寄存器中存放的是**选择子**（selector）。
        
    - **选择子**用作**索引**，指向内存中的**全局描述符表 (GDT)**。
        
    - **全局描述符表 (GDT)** 中存储着一个个**段描述符**。
        
    - **段描述符**包含了内存段的**起始地址、大小、权限**等详细信息。
        

---

### 2. 引入段描述符缓冲寄存器

由于每次访问内存都去 GDT 中查找段描述符效率很低，保护模式引入了**段描述符缓冲寄存器**，这是一个对程序员**不可见**的硬件缓存。

**工作原理：**

1. 当段寄存器被加载一个新的**选择子**时，CPU 会从 GDT 中获取完整的段描述符信息。
    
2. CPU 将这些信息整理并存入对应的**段描述符缓冲寄存器**中。
    
3. 此后，只要段寄存器不改变，CPU 就会直接从这个**缓存寄存器**中读取段信息，从而大大提高访问效率。
    

**该缓存的失效机制是：**

- 只要对段寄存器进行**赋值**（即使赋了相同的值），CPU 都会重新从 GDT 中获取并更新缓存寄存器。
    

---

### 3. 段描述符缓冲寄存器的兼容性

虽然段描述符缓冲寄存器是为保护模式设计的，但它也可以用在实模式下，以提高效率。

- **在实模式下**：当段寄存器被赋值时，段基址左移 4 位后的结果会被存入段描述符缓冲寄存器。此后，只要段寄存器不变，CPU 都会直接从缓存中获取计算好的地址，避免重复计算。![[Pasted image 20250828153135.png]]![[Pasted image 20250828154726.png]]![[Pasted image 20250828161946.png]]![[Pasted image 20250828162000.png]]
- - **`0x66`**：用于反转**数据本身**的大小（例如，`word` ↔ `dword`，即 16 位 ↔ 32 位）。
    
- **`0x67`**：用于反转**计算内存地址方式**的大小（例如，用 16 位寄存器 `[bx]` 寻址 ↔ 用 32 位寄存器 `[eax]` 寻址）。
mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。 其中“寄存器/内存”是乘数。 如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。 如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。 如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积 的高 32 位，eax 是积的低 32 位
对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。 如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。 如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于 寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。 如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于 寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

- **`BYTE` (字节)**: 8 位
    
- **`WORD` (字)**: 16 位
    
- **`DWORD` (Double Word, 双字)**: 32 位
    
- **`QWORD` (Quad Word, 四字)**: 64 位
- - **在16位模式（如实模式）下**：CPU 默认处理的数据单元是 16 位的，也就是一个 **`WORD`**。
    
- **在32位保护模式下**：CPU 最高效、最自然处理的数据单元是 32 位的，也就是一个 **`DWORD`**。
**`0x66`前缀的明确作用**：正如我们之前讨论的，保护模式的默认操作数是32位。当你执行一条16位的压栈指令（例如 `push ax`）时，汇编器会在机器码前加上 `0x66` 这个“操作数大小反转前缀”。这个前缀的作用就是明确地告诉CPU：“**注意！接下来的这条指令，请把操作大小从默认的32位临时切换为16位！**” 因此，CPU收到的命令不是“压入一个值”，而是“**执行一次16位的压栈操作**”，所以它只会移动16位数据，并将栈指针`esp`减2。
当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针 减 4。 当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。 当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。
### 全局描述符表（Global Descriptor Table，GDT）
是保护模式下内存段的登记表
![[Pasted image 20250828192737.png]]：段界限 (Segment Limit)

1. **基本定义**: 段界限是存放在**段描述符**中的一个 **20 位**数值，它用来规定一个内存段的**大小或边界**。
    
2. **粒度 (Granularity) - G位决定单位**: 这个 20 位的段界限值本身不是最终大小，它需要乘以一个“单位”或“粒度”，这个粒度由段描述符中的 **G 位** 决定：
    
    - **G = 0**: 粒度为 **1 字节**。段的最大尺寸可以达到 220 字节，即 **1 MB**。
        
    - **G = 1**: 粒度为 **4 KB**。段的最大尺寸可以达到 220×4KB=232 字节，即 **4 GB**。
        
3. **精确的边界计算公式**: 要计算段内最后一个可访问地址的偏移量（即实际段边界），需要使用以下公式：
    
    实际边界=(描述符中的段界限+1)×粒度−1
    
    - **为什么要 `+1`**：因为描述符中的20位段界限是从0开始的计数。`0xFFFFF` 代表 `0x100000` 个单位。
        
    - **为什么要 `× 粒度`**：将单位数量转换成实际的字节总数。
        
    - **为什么要 `-1`**：因为内存地址是从0开始的。一个大小为N字节的段，其合法的偏移范围是 `0` 到 `N-1`。
        
    
    **示例 (平坦模型)**:
    
    - 段界限字段 = `0xFFFFF`，G位 = `1` (粒度为 4KB, 即 `0x1000` 字节)
        
    - 实际边界 = (`0xFFFFF` + 1) * `0x1000` - 1
        
    - = `0x100000` * `0x1000` - 1
        
    - = `0x100000000` - 1
        
    - = `0xFFFFFFFF` (这覆盖了全部 4GB 内存空间)
        
4. **扩展方向**: 段界限的意义取决于段的类型：
    
    - **向上扩展 (代码段/数据段)**：段界限定义了段内**最大**的有效偏移。合法访问范围是 `0` 到 `实际边界`。
        
    - **向下扩展 (栈段)**：段界限定义了段内**最小**的有效偏移。地址向下增长（`push` 操作使地址变小）。
### 段描述符结构总结

1. **分段的基地址 (Base Address) 是“碎片化”存储的**： 一个完整的 32 位段基地址并不是连续存放在一起的，而是被拆分成了 **三部分**，分散在 64 位的段描述符中：
    
    - **第一部分 (0-15位)**：存放在描述符的**低32位**中。
        
    - **第二部分 (16-23位)**：存放在描述符的**高32位**中。
        
    - **第三部分 (24-31位)**：也存放在描述符的**高32位**中。 在解析一个段描述符时，需要将这三部分拼接起来才能得到完整的32位基地址。
        
2. **S 位：决定描述符的根本性质 (系统 vs. 非系统)**： 段描述符中的 **S 位 (Descriptor Type bit)** 是一个关键的开关，它将描述符分为两大类：
    
    - **S = 0：系统段 (System Segment)**
        
        - 供**硬件**直接使用，用于管理系统级的结构。
            
        - 典型的例子是各种“门”（Gate），如调用门、任务门，它们是硬件定义的程序入口点。
            
    - **S = 1：非系统段 (Code or Data Segment)**
        
        - 供**软件**（包括操作系统和应用程序）使用。
            
        - 从CPU的角度看，无论是**代码、数据还是栈**，都是提供给硬件处理的“数据”，因此它们都属于这一类。
            
3. **Type 字段：依赖 S 位进行精细分类**：
    
    - **Type 字段**是一个 4 位的区域，用来进一步指明段的具体类型（如只读数据、可执行代码等）。
        
    - **关键点**：Type 字段的**具体含义完全取决于 S 位的值**。只有先确定了是系统段（S=0）还是非系统段（S=1），Type 字段中的值才能被正确解读。
        

**一句话总结：** 段描述符通过**S位**来区分是为硬件服务的“系统段”还是为软件服务的“代码/数据段”，然后再结合 **Type 字段**来明确其具体用途。而段的32位起始地址则需要从描述符的三个不同位置读取并组合而成。
![[Pasted image 20250828194004.png]] **Type 字段 (Bits 11-8) 的内部标志位**

`Type` 字段本身由几个独立的标志位组成，用于描述**非系统段（S=1时）**的详细属性：

- **A (Accessed)**: **访问位**。段被CPU访问后，此位由CPU自动置1。
    
- **X (eXecutable)**: **可执行位**。`1`表示代码段，`0`表示数据段。
    
- **E (Extend-direction)**: **扩展方向位**。
    
    - `0` = **向上扩展** (用于代码/数据段，地址由低到高)。
        
    - `1` = **向下扩展** (用于栈段，地址由高到低)。
        
- **W (Writable) / R (Readable)**: **可写/可读位**。
    
    - **数据段**中，此位是 **W**。`1`=可写，`0`=只读。
        
    - **代码段**中，此位是 **R**。`1`=可读，`0`=不可读（但仍可执行）。
        
- **C (Conforming)**: **一致性代码段位**。用于代码段，决定特权级转移的规则。

---

全局描述符表 GDT、局部描述符表 LDT 及选择子
全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里。这个专门的寄存器便是 GDTR， 即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器![[Pasted image 20250828194309.png]]

- **加载GDT：使用 `lgdt` 指令**
    
    - **专用指令**: 不能使用`mov`等通用指令来设置全局描述符表寄存器(GDTR)，必须使用专用的 `lgdt` 指令。
        
    - **操作数格式**: `lgdt` 指令需要一个 48 位的内存地址作为操作数，这48位数据包含两部分：
        
        - **前16位**: GDT 表的**界限 (Limit)**，即 GDT 的总字节大小减 1。
            
        - **后32位**: GDT 表的**起始物理地址 (Base Address)**。
            
    - **使用时机**: 该指令既可以在**实模式**下执行（为进入保护模式做准备），也可以在**保护模式**下再次执行（用于重新定位或更换GDT）。
        
- **GDT的容量**
    
    - 由于 `lgdt` 指令中的界限字段是 16 位，所以GDT本身最大为 216 = 65536 字节（64 KB）。
        
    - 每个段描述符固定占用 8 字节。
        
    - 因此，一个GDT中最多可以容纳 65536 / 8 = **8192 个描述符**。
        
- **保护模式下的段寄存器：内容变为“段选择子” (Selector)**
    
    - **根本性转变**: 段寄存器（CS, DS, SS等）的用途发生了根本改变。
        
    - **实模式下**: 段寄存器存放的是**段基地址**。
        
    - **保护模式下**: 段基地址等信息已经存入了GDT的描述符中。段寄存器不再存放基地址，而是存放一个称为 **“选择子” (Selector)** 的值。
        
    - **选择子的作用**: 选择子本质上是一个**索引**，它指向GDT中的某一个具体的段描述符。CPU通过这个“索引”去GDT中找到对应的“身份证”（段描述符），从而获取到该段的基地址、界限、权限等所有信息。