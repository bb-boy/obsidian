## **BIOS
### 1. **BIOS的作用和存放位置**

- **作用**：BIOS（Basic Input/Output System）是计算机加电后运行的第一段程序，负责**硬件的自检和初始化**，以及后续操作系统引导的准备工作。
- **存放位置**：BIOS固化在**主板上的ROM芯片**里。ROM（只读存储器）断电后数据不会丢失，非常适合存储“启动时必须有”的程序代码。

---

### 2. **BIOS的入口和实模式寻址**

- **入口地址**：CPU复位后，会自动跳到物理地址`0xFFFF0`处执行BIOS（其实这只是BIOS映像的末尾，实际只放一个跳转指令）。
- **CS:IP寻址机制**：实模式下，CS:IP（代码段:指令指针）组合起来可以寻址20位物理地址，即`(CS << 4) + IP`。例如启动时CS=0xF000, IP=0xFFF0，最终地址就是`0xFFFF0`。
- **跳转原理**：`0xFFFF0`只存了一个“跳转指令”，实际BIOS代码在别处，比如`0xFE05B`。

---

### 3. **BIOS初始化及中断向量表**

- BIOS会对**内存、显卡、键盘等外设做自检**和初始化，还要给后续系统引导做准备。
- BIOS最重要的工作之一：**建立中断向量表（Interrupt Vector Table, IVT）**。
    - 位置：实模式下，**中断向量表位于内存0x0000 ~ 0x03FF**（即前1KB空间）。
    - 作用：存放256个中断类型（0~255，每个4字节），每个中断的入口地址，也就是“向量”。
    - 这样，CPU遇到`int xx`指令（如`int 0x80`），就能从IVT查到处理该中断的函数地址，快速跳转过去执行对应服务。

---

### 4. **BIOS到MBR的流程梳理**

- BIOS初始化硬件
- 建立中断向量表
- 加载并跳转到**MBR（主引导记录）**，为操作系统启动做准备

---
### **BIOS的最后一项任务**

- **检测磁盘**：BIOS会去检查“0盘0道1扇区”（即第一个硬盘的第一个柱面、第一扇区）内容。
- **历史原因**：扇区编号从1开始，所以“1扇区”其实是第一个扇区，不用纠结。

## **MBR的“魔数”检测**

- **魔数**：BIOS会检查这个扇区最后两个字节（第511字节和第512字节）。
    - 必须分别为`0x55`和`0xAA`（小端序存储，其实在内存中是`0xAA55`）。
- **作用**：这是一种“标记”，告诉BIOS“这是一个有效的启动扇区（可引导扇区）”。

##  **MBR的加载位置和执行**

- **加载位置**：如果检测到魔数，BIOS会把整个512字节的MBR代码加载到**内存的物理地址0x7C00**处。
- **跳转执行**：接着CPU会跳转到0x7C00，开始执行MBR里的引导程序（这也是我们写自制操作系统时第一个能“跑起来”的自己的代码）。

##  **MBR相关规定**

- **大小**：MBR固定为**512字节**。
- **末尾魔数**：第511字节和第512字节必须是`0xAA`、`0x55`（用小端序存储，实际为`0x55AA`）。
- **内容**：前446字节通常存放引导程序代码，接着64字节是分区表，最后2字节是魔数。
- **小端序**：因为x86平台是小端序，所以存储顺序是低字节在前（即`0x55`，再是`0xAA`）。

<<<<<<< HEAD
![[操作系统/shot/image 1.png]]![[计算机启动流程.png]]


## 保护模式入门
开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

---



## 全局描述符表 (Global Descriptor Table, GDT)

- **本质**: 全局描述符表是一个储存在内存中的“表”，它由一系列被称为 **段描述符** 的表项组成。
    
- **表项 (段描述符)**: 表中的每一个条目都称为一个段描述符，其大小为 **64 字节**。每个段描述符都用来详细描述一个内存段，包括它的**起始地址**、**大小**和**访问权限**等信息。
    
- **存放位置与引用**: 由于该表可能非常大，因此它被存放在内存中。处理器使用 **GDTR 寄存器** 来指向该表的起始位置，从而能够找到并访问它。
    

简而言之，全局描述符表就像一个目录，列出了所有可用的内存段，而 GDTR 寄存器则像一个指针，指向这个目录的起点，让处理器可以快速找到它。

---

### 1. 从实模式到保护模式的转变

在实模式下，CPU（如 8086）直接使用**段基址**和**偏移地址**计算出物理地址。

- **实模式（16 位）**：
    
    - 段寄存器中存放的是**段基址**。
        
    - 物理地址 = **段基址**左移 4 位 + **偏移地址**。
        
    - 每次访问都需进行计算，效率较低。
        

在保护模式下，为了增强安全性和灵活性，段寄存器不再直接存储段基址。

- **保护模式（32 位及以上）**：
    
    - 段寄存器中存放的是**选择子**（selector）。
        
    - **选择子**用作**索引**，指向内存中的**全局描述符表 (GDT)**。
        
    - **全局描述符表 (GDT)** 中存储着一个个**段描述符**。
        
    - **段描述符**包含了内存段的**起始地址、大小、权限**等详细信息。
        

---

### 2. 引入段描述符缓冲寄存器

由于每次访问内存都去 GDT 中查找段描述符效率很低，保护模式引入了**段描述符缓冲寄存器**，这是一个对程序员**不可见**的硬件缓存。

**工作原理：**

1. 当段寄存器被加载一个新的**选择子**时，CPU 会从 GDT 中获取完整的段描述符信息。
    
2. CPU 将这些信息整理并存入对应的**段描述符缓冲寄存器**中。
    
3. 此后，只要段寄存器不改变，CPU 就会直接从这个**缓存寄存器**中读取段信息，从而大大提高访问效率。
    

**该缓存的失效机制是：**

- 只要对段寄存器进行**赋值**（即使赋了相同的值），CPU 都会重新从 GDT 中获取并更新缓存寄存器。

---

### 3. 段描述符缓冲寄存器的兼容性

虽然段描述符缓冲寄存器是为保护模式设计的，但它也可以用在实模式下，以提高效率。

- **在实模式下**：当段寄存器被赋值时，段基址左移 4 位后的结果会被存入段描述符缓冲寄存器。此后，只要段寄存器不变，CPU 都会直接从缓存中获取计算好的地址，避免重复计算。![[不同模式段寄存器作用.png]]![[机器码格式.png]]![[不用模式下寻址方式.png]]![[不用模式下反转指令.png]]
**mul** 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。 其中“寄存器/内存”是乘数。 如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。 如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。 如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积 的高 32 位，eax 是积的低 32 位
**对于无符号数除法指令 div**，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。 如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。 如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于 寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。 如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于 寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

- **`BYTE` (字节)**: 8 位
    
- **`WORD` (字)**: 16 位
    
- **`DWORD` (Double Word, 双字)**: 32 位
    
- **`QWORD` (Quad Word, 四字)**: 64 位
- - **在16位模式（如实模式）下**：CPU 默认处理的数据单元是 16 位的，也就是一个 **`WORD`**。
    
- **在32位保护模式下**：CPU 最高效、最自然处理的数据单元是 32 位的，也就是一个 **`DWORD`**。

**`0x66`**：用于反转**数据本身**的大小（例如，`word` ↔ `dword`，即 16 位 ↔ 32 位）。
**`0x67`**：用于反转**计算内存地址方式**的大小（例如，用 16 位寄存器 `[bx]` 寻址 ↔ 用 32 位寄存器 `[eax]` 寻址）。

**`0x66`前缀的明确作用**：正如我们之前讨论的，保护模式的默认操作数是32位。当你执行一条16位的压栈指令（例如 `push ax`）时，汇编器会在机器码前加上 `0x66` 这个“操作数大小反转前缀”。这个前缀的作用就是明确地告诉CPU：“**注意！接下来的这条指令，请把操作大小从默认的32位临时切换为16位！**” 因此，CPU收到的命令不是“压入一个值”，而是“**执行一次16位的压栈操作**”，所以它只会移动16位数据，并将栈指针`esp`减2。
当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针 减 4。 当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。 当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。
### 全局描述符表（Global Descriptor Table，GDT）

是保护模式下内存段的登记表
![[段描述符.png]]：段界限 (Segment Limit)

1. **基本定义**: 段界限是存放在**段描述符**中的一个 **20 位**数值，它用来规定一个内存段的**大小或边界**。
    
2. **粒度 (Granularity) - G位决定单位**: 这个 20 位的段界限值本身不是最终大小，它需要乘以一个“单位”或“粒度”，这个粒度由段描述符中的 **G 位** 决定：
    
    - **G = 0**: 粒度为 **1 字节**。段的最大尺寸可以达到 220 字节，即 **1 MB**。
        
    - **G = 1**: 粒度为 **4 KB**。段的最大尺寸可以达到 220×4KB=232 字节，即 **4 GB**。
        
3. **精确的边界计算公式**: 要计算段内最后一个可访问地址的偏移量（即实际段边界），需要使用以下公式：
    
    实际边界=(描述符中的段界限+1)×粒度−1
    
    - **为什么要 `+1`**：因为描述符中的20位段界限是从0开始的计数。`0xFFFFF` 代表 `0x100000` 个单位。
        
    - **为什么要 `× 粒度`**：将单位数量转换成实际的字节总数。
        
    - **为什么要 `-1`**：因为内存地址是从0开始的。一个大小为N字节的段，其合法的偏移范围是 `0` 到 `N-1`。
        
    
    **示例 (平坦模型)**:
    
    - 段界限字段 = `0xFFFFF`，G位 = `1` (粒度为 4KB, 即 `0x1000` 字节)
        
    - 实际边界 = (`0xFFFFF` + 1) * `0x1000` - 1
        
    - = `0x100000` * `0x1000` - 1
        
    - = `0x100000000` - 1
        
    - = `0xFFFFFFFF` (这覆盖了全部 4GB 内存空间)
        
4. **扩展方向**: 段界限的意义取决于段的类型：
    
    - **向上扩展 (代码段/数据段)**：段界限定义了段内**最大**的有效偏移。合法访问范围是 `0` 到 `实际边界`。
        
    - **向下扩展 (栈段)**：段界限定义了段内**最小**的有效偏移。地址向下增长（`push` 操作使地址变小）。
### 段描述符结构总结

1. **分段的基地址 (Base Address) 是“碎片化”存储的**： 一个完整的 32 位段基地址并不是连续存放在一起的，而是被拆分成了 **三部分**，分散在 64 位的段描述符中：
    
    - **第一部分 (0-15位)**：存放在描述符的**低32位**中。
        
    - **第二部分 (16-23位)**：存放在描述符的**高32位**中。
        
    - **第三部分 (24-31位)**：也存放在描述符的**高32位**中。 在解析一个段描述符时，需要将这三部分拼接起来才能得到完整的32位基地址。
        
2. **S 位：决定描述符的根本性质 (系统 vs. 非系统)**： 段描述符中的 **S 位 (Descriptor Type bit)** 是一个关键的开关，它将描述符分为两大类：
    
    - **S = 0：系统段 (System Segment)**
        
        - 供**硬件**直接使用，用于管理系统级的结构。
            
        - 典型的例子是各种“门”（Gate），如调用门、任务门，它们是硬件定义的程序入口点。
            
    - **S = 1：非系统段 (Code or Data Segment)**
        
        - 供**软件**（包括操作系统和应用程序）使用。
            
        - 从CPU的角度看，无论是**代码、数据还是栈**，都是提供给硬件处理的“数据”，因此它们都属于这一类。
            
3. **Type 字段：依赖 S 位进行精细分类**：
    
    - **Type 字段**是一个 4 位的区域，用来进一步指明段的具体类型（如只读数据、可执行代码等）。
        
    - **关键点**：Type 字段的**具体含义完全取决于 S 位的值**。只有先确定了是系统段（S=0）还是非系统段（S=1），Type 字段中的值才能被正确解读。
        

**一句话总结：** 段描述符通过**S位**来区分是为硬件服务的“系统段”还是为软件服务的“代码/数据段”，然后再结合 **Type 字段**来明确其具体用途。而段的32位起始地址则需要从描述符的三个不同位置读取并组合而成。
![[段描述符高32位.png]] **Type 字段 (Bits 11-8) 的内部标志位**

`Type` 字段本身由几个独立的标志位组成，用于描述**非系统段（S=1时）**的详细属性：

- **A (Accessed)**: **访问位**。段被CPU访问后，此位由CPU自动置1。
    
- **X (eXecutable)**: **可执行位**。`1`表示代码段，`0`表示数据段。
    
- **E (Extend-direction)**: **扩展方向位**。
    
    - `0` = **向上扩展** (用于代码/数据段，地址由低到高)。
        
    - `1` = **向下扩展** (用于栈段，地址由高到低)。
        
- **W (Writable) / R (Readable)**: **可写/可读位**。
    
    - **数据段**中，此位是 **W**。`1`=可写，`0`=只读。
        
    - **代码段**中，此位是 **R**。`1`=可读，`0`=不可读（但仍可执行）。
        
- **C (Conforming)**: **一致性代码段位**。用于代码段，决定特权级转移的规则。

---

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里。这个专门的寄存器便是 GDTR， 即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器![[GDT寄存器.png]]

- **加载GDT：使用 `lgdt` 指令**
    
    - **专用指令**: 不能使用`mov`等通用指令来设置全局描述符表寄存器(GDTR)，必须使用专用的 `lgdt` 指令。
        
    - **操作数格式**: `lgdt` 指令需要一个 48 位的内存地址作为操作数，这48位数据包含两部分：
        
        - **前16位**: GDT 表的**界限 (Limit)**，即 GDT 的总字节大小减 1。
            
        - **后32位**: GDT 表的**起始物理地址 (Base Address)**。
            
    - **使用时机**: 该指令既可以在**实模式**下执行（为进入保护模式做准备），也可以在**保护模式**下再次执行（用于重新定位或更换GDT）。
        
- **GDT的容量**
    
    - 由于 `lgdt` 指令中的界限字段是 16 位，所以GDT本身最大为 216 = 65536 字节（64 KB）。
        
    - 每个段描述符固定占用 8 字节。
        
    - 因此，一个GDT中最多可以容纳 65536 / 8 = **8192 个描述符**。
        
- **保护模式下的段寄存器：内容变为“段选择子” (Selector)**
    
    - **根本性转变**: 段寄存器（CS, DS, SS等）的用途发生了根本改变。
        
    - **实模式下**: 段寄存器存放的是**段基地址**。
        
    - **保护模式下**: 段基地址等信息已经存入了GDT的描述符中。段寄存器不再存放基地址，而是存放一个称为 **“选择子” (Selector)** 的值。
        
    - **选择子的作用**: 选择子本质上是一个**索引**，它指向GDT中的某一个具体的段描述符。CPU通过这个“索引”去GDT中找到对应的“身份证”（段描述符），从而获取到该段的基地址、界限、权限等所有信息。
### 段选择子 (Selector) 总结

1. **定义与用途**: 在保护模式下，16位的段寄存器（如 CS, DS）中存放的不再是段基地址，而是一个16位的 **段选择子 (Selector)**。它的核心作用是作为**索引**，用于在描述符表（GDT或LDT）中**定位**一个具体的段描述符。
    
2. **16位结构拆解**: 一个选择子被精确地划分为三个部分：![[选择子.png]]
3. **工作流程与最终目的**: 尽管保护模式的内存访问机制变了，但最终形式上依然是 **“段基址 : 段内偏移地址”**。这个过程由CPU自动完成：

	1. CPU从段寄存器中获取**选择子**。
	    
	2. 使用选择子中的 **TI位** 确定是在GDT还是LDT中查找。
	    
	3. 使用选择子中的 **Index** 在该表中找到对应的段描述符。
	    
	4. CPU**自动从段描述符中取出32位的段基地址**。
	    
	5. 将这个基地址与指令中的**段内偏移地址**相加，最终形成要访问的线性地址。

**GDT 中的第 0 个段描述符是不可用的，原因是定义在 GDT 中的段描 述符是要用选择子来访问的，如果使用的选择子忘记初始化，选择子的值便会是 0，这便会访问到第 0 个 段描述符**

[[`在 x86 架构中，当计算机启动时，CPU 处于实模式（Real Mode），并且所有段寄存器（包括 cs）都被初始化为特定的值。具体来说，cs 被设置为 0xf000，而指令指针 ip 被设置为 0xfff0。这意味着 CPU 启动时的地址是 0xffff0（cs << 4 + ip = 0xf0000 + 0xfff0 = 0xffff0）。`

`BIOS 的入口点通常位于这个地址附近。BIOS 会执行一系列初始化操作，然后将主引导记录（MBR）加载到内存地址 0x7c00 处，并将 cs 设置为 0x0000，ip 设置为 0x7c00，从而使 CPU 跳转到 MBR 代码开始执行。`]]



## 保护模式式进阶



### 内存检测

---

#### **方法一：`AH = 0x88` 功能**

这是最古老、最简单的一种方法。

- **核心功能：** 获取大于1MB的扩展内存大小。
    
- **使用方法：**
    
    1. 将`AH`寄存器设置为`0x88`。
        
    2. 调用`int 0x15`中断。
        
- **结果解读：**
    
    - 中断返回后，`AX`寄存器中的值就是**以KB为单位**的内存容量（不包含低端1MB）。
        
    - **总内存 ≈ AX * 1024 + 1MB**。
        
- **优点：**
    
    - 调用非常简单，一行汇编指令即可。
        
- **缺点：**
    
    - **有64MB的上限。** 这是它最致命的弱点。无论系统实际有多少内存，此功能最多返回64MB（减去1MB后对应的值）。对于现代计算机来说，这个方法基本已经过时。
        

---

#### **方法二：`AX = 0xE801` 功能**

这是一个过渡时期的增强方法，比`AH=0x88`更强大，但仍有局限。

- **核心功能：** 分段检测内存，最高可支持到4GB。
    
- **使用方法：**
    
    1. 将`AX`寄存器设置为`0xE801`。
        
    2. 调用`int 0x15`中断。
        
- **结果解读：**
    
    - 中断返回后，结果被分成了两部分存放在不同的寄存器中：
        
        - `AX` (或 `CX`): 存放**1MB到16MB之间**的内存大小，单位是**KB**。
            
        - `BX` (或 `DX`): 存放**16MB以上**的内存大小，单位是**64KB**。
            
    - **总内存 ≈ (AX * 1KB) + (BX * 64KB) + 1MB**。
        
- **优点：**
    
    - 相比`AH=0x88`，检测上限大大提高，能处理4GB以内的内存。
        
- **缺点：**
    
    - **检测结果不直观**，需要拼接两部分结果。
        
    - **仍然有4GB的上限**，无法应对超过4GB内存的64位系统。
        
    - **可能不完全准确**，无法识别出内存中可能存在的“空洞”（被硬件保留的地址段）。
        

---

#### **方法三：`EAX = 0xE820` 功能 (现代标准方法)**

这是目前最强大、最准确、也是现代操作系统和引导加载程序**唯一推荐使用**的方法。它返回的不是一个简单的总容量，而是一个完整的**系统内存布局图（Memory Map）**。

- **核心功能：** 获取一个由**地址范围描述符（Address Range Descriptor Structure, ARDS）**组成的列表，详细描述了系统中所有内存段的起始地址、长度和类型。
    
- **使用方法：**
    
    - 这是一个**循环调用**的过程。
        
    
    1. **首次调用：** 将`EAX`设为`0xE820`，`EBX`设为`0`，`EDX`设为魔数`0x534D4150` ('SMAP')，并让`ES:DI`指向一个足够大的缓冲区（至少20字节）。
        
    2. 调用`int 0x15`。
        
    3. **后续调用：** 如果上一次调用成功（`CF`标志位为0且`EBX`不为0），则将返回的`EBX`值作为下一次调用的输入，再次调用`int 0x15`，直到`EBX`返回0为止。
        
- **结果解读：**
    
    - 每次成功调用后，`ES:DI`指向的缓冲区会被填充一个**ARDS**结构，该结构包含：
        
        - **BaseAddr (64位):** 内存段的起始地址。
            
        - **Length (64位):** 内存段的长度（以字节为单位）。
            
        - **Type (32位):** 内存段的类型（例如，Type 1是可用内存，Type 2是保留内存，不可使用）。
            
    - 通过遍历所有ARDS，将所有**Type为1（可用）**的内存段的长度相加，就能得到最准确的可用物理内存总量。
        
- **优点：**
    
    - **极其准确和全面：** 能识别所有内存区域，包括不连续的内存和“空洞”。
        
    - **没有容量上限：** 支持64位地址空间，可以检测任意大小的内存。
        
    - **提供详细信息：** 不仅知道有多大内存，还知道这些内存在哪里、是否可用。
        
- **缺点：**
    
    - **实现最复杂：** 需要编写循环，并解析返回的数据结构。
        

---

#### **总结对比**

| 特性         | 方法一 (`AH=0x88`) | 方法二 (`AX=0xE801`) | 方法三 (`EAX=0xE820`)  |
| ---------- | --------------- | ----------------- | ------------------- |
| **功能码**    | `AH = 0x88`     | `AX = 0xE801`     | `EAX = 0xE820`      |
| **最大检测容量** | 64MB            | 4GB               | 无实际限制 (64位)         |
| **返回信息**   | 1MB以上的总容量 (KB)  | 两段式的容量 (KB和64KB块) | 详细的**内存布局图 (ARDS)** |
| **实现复杂度**  | **非常简单**        | 简单                | **复杂** (需要循环和解析)    |
| **准确性**    | 低，有硬上限          | 中等，无法识别内存空洞       | **非常高**，最可靠         |
| **推荐度**    | 已过时，不推荐         | 过渡方案，不推荐          | **现代系统唯一推荐**        |



### 1. CF标志位的“双重身份”

CPU中的标志寄存器（FLAGS/EFLAGS）有很多位，每一位都有特定的含义。**进位标志位（CF）**有两个主要作用：

1. **本职工作（硬件层面）：** 在执行**算术运算**时，CF用来表示无符号数的溢出。例如，一个8位的数`11111111`加1后，结果是`00000000`，但CF位会被置为1，表示“有进位产生”。在减法中，它充当“借位”标志。
    
2. **兼职工作（软件层面）：** 正是因为CF是一个很容易被设置（置1）或清除（清0）的独立标志位，早期的系统程序员们（比如设计IBM PC BIOS和MS-DOS的那些人）就**约定**用它来作为一个通用的**函数调用成功/失败的信号**。


---

### **`jc` (Jump on Carry) - 如果有进位则跳转**

- **完整名称：** Jump on Carry / 如果进位则跳转
    
- **检查的标志位：** **CF (Carry Flag / 进位标志位)**
    
- **跳转条件：** 当 `CF = 1` 时，执行跳转。
    

**`jc` 主要用于以下场景：**

1. 检查无符号数运算是否溢出或借位：
    
    这是CF标志位的本职工作。
    
    - **加法溢出：** 两个无符号数相加，结果超出了寄存器能表示的最大范围。
        
        代码段
        
        ```
        mov al, 0xFF  ; AL = 255
        add al, 1     ; 255 + 1 = 256, 超出8位范围, 结果AL=0, CF=1
        jc overflow_handler ; CF=1, 所以会跳转
        ```
        
    - **减法借位：** 一个小的无符号数减去一个大的无符号数。
        
        代码段
        
        ```
        mov al, 5
        sub al, 10    ; 5 - 10, 需要借位, 结果AL=251, CF=1
        jc borrow_handler ; CF=1, 所以会跳转
        ```
        
2. **检查BIOS或系统调用的失败信号：**
    
    - 正如我们之前讨论的，很多BIOS和DOS中断服务，**约定使用 `CF=1` 来表示调用失败**。`jc` 正是用来捕获这种失败信号的指令。
        
        代码段
        
        ```
        mov eax, 0xe820
        int 0x15
        jc bios_call_failed ; 如果BIOS调用失败(CF=1), 则跳转到错误处理
        ```
        
3. **检查位操作移出的比特：**
    
    - 在移位指令（如`shl`, `shr`）中，被移出寄存器的最后一位会进入CF。
        

---

### **`jnz` (Jump if Not Zero) - 如果不为零则跳转**

- **完整名称：** Jump if Not Zero / 如果不为零则跳转
    
- **等价指令：** `jne` (Jump if Not Equal / 如果不相等则跳转)。`jnz` 和 `jne` 是完全相同的指令，会被编译成同一个机器码。
    
- **检查的标志位：** **ZF (Zero Flag / 零标志位)**
    
- **跳转条件：** 当 `ZF = 0` 时，执行跳转。（注意：`ZF=1` 表示结果为零，`ZF=0` 表示结果不为零）
    

**`jnz` 主要用于以下场景：**

1. **检查两个数是否不相等（与`cmp`配合）：**
    
    - `cmp` 指令会计算两个操作数的差，并根据结果设置标志位。如果两个数相等，差为零，`ZF`会被置为1。
        
        代码段
        
        ```
        cmp eax, ebx   ; 比较eax和ebx
        jne values_are_not_equal ; 如果eax不等于ebx (差不为零, ZF=0), 则跳转
        ```
        
2. **检查运算结果是否不为零：**
    
    - 任何影响ZF标志位的算术或逻辑运算之后，都可以用`jnz`来判断结果。
        
        代码段
        
        ```
        sub eax, eax   ; eax = eax - eax = 0。ZF会被置为1
        jnz label      ; ZF=1, 所以不会跳转
        ```
        
3. **实现循环（最常见的用途之一）：**
    
    - 通过一个计数器递减，只要计数器还不为零，就继续循环。
        
        代码段
        
        ```
        mov ecx, 10    ; 设置循环次数为10
        loop_start:
          ; ... 循环体内的代码 ...
          dec ecx      ; ecx减1。当ecx从1减到0时, ZF会置为1
          jnz loop_start ; 只要ecx还不为0(ZF=0), 就跳回loop_start
        ; ecx为0后, 循环结束, 执行这里的代码
        ```
        

---

### **总结对比**

|特性|`jc` (Jump on Carry)|`jnz` (Jump if Not Zero)|
|---|---|---|
|**中文含义**|如果**进位/借位**则跳转|如果结果**不为零**则跳转|
|**检查的标志位**|**CF (进位标志位)**|**ZF (零标志位)**|
|**跳转条件**|`CF = 1`|`ZF = 0`|
|**等价指令**|无|`jne` (如果不相等则跳转)|
|**核心应用场景**|检查**无符号数**运算、位操作、**BIOS/系统调用失败**|检查两个数是否**不相等**、运算结果是否**非零**、**循环控制**|
|**典型前置指令**|`add`, `sub`, `shl`, `stc`, `int`|`cmp`, `test`, `dec`, `inc`, `sub`, `and`|

一句话总结：

jc 关心的是运算过程“有没有溢出或出错”，而 jnz 关心的是运算结果“是不是零”。它们是为解决完全不同的逻辑问题而设计的。




>
> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=199&annotation=7997R|操作系统真象还原 (郑纲), p.199]]
> 我们利用它实现段式内存管理。如果该描述符中 的  P  位为  1，表示该段在内存中存在。访问过该段后，CPU  将段描述符中的  A  位置  1，表示近来刚访问过该段。 相反，如果  P  位为  0，说明内存中并不存在该段，这时候  CPU  将会抛出个  NP（段不存在）异常，转而去执行中 断描述符表中  NP  异常对应的中断处理程序，此中断处理程序是操作系统负责提供的，该程序的工作是将相应的 段从外存（比如硬盘）中载入到内存，并将段描述符的  P  位置  1，中断处理函数结束后返回，CPU  重复执行这个 检查，继续查看该段描述符的  P  位，此时已经为  1  了，在检查通过后，将段描述符的  A  位置  1。
段描述符的 A 位由 CPU 置 1，但清 0 工作可是由操作系统来完成的。此位干吗用的呢？如果仅仅用来表示该段被访问过，这也意义不大啊。其实这正是软件和硬件相互配合的体现，操作系统每发现该位为 1 后就将该位清 0，这样一来，在一个周期内统计该位为 1 的次数就知道该段的使用频率了，从而可以找出使用频率最低的段。当物理内存不足时，可以将使用频率最低的段换出到硬盘，以腾出内存空间给新的进程。当段被换出到硬盘后， 操作系统将该段描述符的 P 位置 0。当下次这个进程上 CPU 运行后，如果访问了这个段，这样程序流就回到了刚开始 CPU 检查出 P 位为 0、紧接着抛出异常、执行操作系统中断处理程序、换入内存段的循环




|标志位（缩写）|全称|意义说明|取值/作用说明|
|---|---|---|---|
|**P**|Present|存在位，页是否在物理内存中|1：在内存；0：不在，访问会pagefault异常|
|**RW**|Read/Write|读写位，页是否可写|1：可读可写；0：只读|
|**US**|User/Supervisor|用户/特权级位，决定哪类特权可访问|1：用户/所有级别可访问；0：仅超级用户/高特权可访问|
|**PWT**|Page-level Write-Through|页级写透位，是否使用写透缓存|1：写透方式；0：回写方式|
|**PCD**|Page-level Cache Disable|页级高速缓存禁止位|1：禁止该页缓存在缓存中；0：允许缓存|
|**A**|Accessed|访问位，页是否被CPU访问过|1：被访问过，CPU自动置位|
|**D**|Dirty|脏页位，页内容是否被写过|1：被写过，CPU自动置位|
|**PAT**|Page Attribute Table|页属性表位，扩展页属性|复杂用法，通常为0|
|**G**|Global|全局页位，是否为全局页（不因TLB刷新而失效）|1：全局页，刷新CR3时TLB不清除此页|
|**AVL**|Available for Software|软件保留位，操作系统可自定义使用|—|

---

### **简要说明：**

- **P/RW/US** 是最常用、最核心的权限/存在相关标志。
- **PWT/PCD/PAT** 是缓存相关的优化与扩展功能。
- **A/D** 用于追踪访问与写入状态（由CPU硬件自动更新）。
- **G** 影响页表项在TLB中的驻留策略。
- **AVL** 是“软定义”，通常操作系统自用。

#### cr0寄存器


|  位号 | 缩写     | 名称                  | 置 1 的含义                                         | 置 0 的含义               | 常见备注                         |
| --: | ------ | ------------------- | ----------------------------------------------- | --------------------- | ---------------------------- |
|   0 | **PE** | Protection Enable   | 进入**保护模式**（需先准备好GDT等）                           | 实模式                   | 打开分页前通常先置 PE=1               |
|   1 | **MP** | Monitor Coprocessor | 在 **TS=1** 时，`WAIT/FWAIT` 会触发 **#NM**（配合懒切换FPU） | `WAIT/FWAIT` 不受 TS 影响 | 与 **TS** 配合监控协处理器使用          |
|   2 | **EM** | Emulation           | **无 x87**，所有 x87 指令触发 **#NM**（软件仿真）             | 存在 x87/FPU            | 现代机一般 EM=0                   |
|   3 | **TS** | Task Switched       | 置位后首个 x87/SSE 指令触发 **#NM**（用于**懒保存/恢复**浮点上下文）   | 不触发                   | OS 在任务切换时置 1，使用后清 0          |
|   4 | **ET** | Extension Type      | 历史位；在 486+ 上恒为 **1**                            | —                     | 只为兼容保留                       |
|   5 | **NE** | Numeric Error       | x87 异常通过 **#MF(16)** 上报（内部方式）                   | 旧式 FERR#/IRQ13 方式     | 现代 OS 必置 **1**               |
|  16 | **WP** | Write Protect       | **内核态也不得写**只读页（更强保护）                            | 内核态可写只读页              | 现代 OS 常置 **1**               |
|  18 | **AM** | Alignment Mask      | **用户态**且 `EFLAGS.AC=1` 时，对未对齐访问触发 **#AC**       | 不做对齐检查                | 调试/健壮性检查                     |
|  29 | **NW** | Not Write-through   | 与 **CD** 联合控制缓存写策略；通常为 **0**                    | —                     | 现代系统多设 NW=0；关闭缓存时常与 CD 一起置 1 |
|  30 | **CD** | Cache Disable       | **禁用缓存**（需配合 `WBINVD`/`INVD` 刷新）                | 允许缓存                  | 临时关缓存做内存测试/设备访问              |
|  31 | **PG** | Paging              | **启用分页**（结合 CR3/CR4 设置）                         | 线性地址=物理地址（无分页）        | 开启长模式/PAE 等也需要 PG=1          |

**注意事项**

- 未列出的位为**保留位**，应按手册要求写 0。
- 打开分页的典型顺序：准备页表→写 CR3→（已 PE=1）置 PG=1；若使用 PAE/长模式，还需先配好 **CR4**、**EFER**。
- 关闭/开启缓存（CD/NW）前后应按手册要求**刷新缓存**并注意 MTRR/PAT 的影响。

bochs 支持很多 `info` 子命令，主要用于**查看系统当前的硬件/虚拟内存/寄存器/断点等状态**。

### 常用 info 命令有：

- `info tab`  
    查看当前的**虚拟地址到物理地址的页表映射**（paging translation）。
- `info reg`  
    查看 CPU 寄存器内容（eax、ebx、cr0、cr3等）。
- `info break`  
    查看断点信息。
- `info cpu`  
    查看CPU状态（模式、标志等）。
- `info seg`  
    查看段寄存器详细信息





### Kernel



下面把你贴的几页内容按“是什么—怎么看—用来干嘛”的思路梳理成一张速记单。

# 1）ELF 是什么

* **ELF（Executable and Linkable Format）**：Unix/Linux 常用的目标文件格式，既面向**链接**（linking），也面向**装载/运行**（execution）。
* 常见三种文件类型（`e_type`）

  * **ET\_REL（可重定位文件）**：编译后未链接的 `.o`；给链接器用。
  * **ET\_EXEC（可执行文件）**：最终可执行；给加载器/内核用。
  * **ET\_DYN（共享目标/动态库）**：`*.so`；既可被装载为共享库，也可作为位置无关可执行由动态加载器启动。
    （还有 ET\_CORE 等）

# 2）两种“视图”：段 vs. 节

* **执行视图（Segments）**：运行时真正被映射/装载的单位，描述在内存中的布局。

  * 由 **Program Header Table**（程序头表）描述。
* **链接视图（Sections）**：链接时操作的单位（`.text`、`.data`、`.bss`、`.rodata`、`.symtab`、`.strtab`、`.rel*` 等）。

  * 由 **Section Header Table**（节头表）描述。
* 关系：多个 **section** 会被归并/映射到少数几个 **segment** 中（例如把 `.text`、只读常量等合并进可装载的代码段）。

# 3）ELF 文件总结构（自上而下）

1. **ELF Header（文件头，`Elf32_Ehdr`）**——总目录
2. **Program Header Table（程序头表）**——执行用目录（可选/对 ET\_REL 可为空）
3. **各个 Section 的数据**——真正内容
4. **Section Header Table（节头表）**——链接用目录（可选/对某些最小可执行也可无）

# 4）ELF Header 关键字段（选 32 位为例）

* `e_ident[16]`：魔数与元信息

  * `0..3`：`0x7F 'E' 'L' 'F'` 魔数
  * `EI_CLASS`（`e_ident[4]`）：32/64 位
  * `EI_DATA`（`e_ident[5]`）：大小端（LSB/MSB）
  * 还包含版本、ABI、ABI 版本等
* `e_type`：文件类型（ET\_REL/ET\_EXEC/ET\_DYN/ET\_CORE/…）
* `e_machine`：体系结构（如 `EM_386` 表示 i386）
* `e_entry`：入口虚拟地址（可执行/动态库重要）
* `e_phoff` / `e_shoff`：程序头表/节头表在文件内的偏移
* `e_flags`：体系结构相关标志
* `e_ehsize`：ELF 头大小
* `e_phentsize`、`e_phnum`：程序头表项大小/数量
* `e_shentsize`、`e_shnum`：节头表项大小/数量
* `e_shstrndx`：节名字符串表所在的节下标

> 小技巧：`file a.out` 会直接显示 “ELF 32-bit LSB …”，等价于读取 `e_ident` 的关键信息。

# 5）Program Header（`Elf32_Phdr`）——装载器看什么

每个表项描述一个段或与装载相关的信息：

* `p_type`：段类型

  * 常见：

    * **PT\_LOAD**（可装载段）
    * **PT\_DYNAMIC**（动态链接信息）
    * **PT\_INTERP**（动态链接器路径）
    * **PT\_NOTE**（注记）
    * **PT\_PHDR**（程序头本身所在映射）
    * 以及保留/平台相关 `PT_LOPROC..PT_HIPROC`
* `p_offset`：该段在**文件**内的起始偏移
* `p_vaddr`：该段在**内存**中的虚拟地址
* `p_paddr`：物理地址（多数用户态系统忽略）
* `p_filesz`：文件中该段大小
* `p_memsz`：装载到内存后的大小（可大于 `p_filesz`，如 `.bss`）
* `p_flags`：访问权限标志 **PF\_X/PF\_W/PF\_R**
* `p_align`：对齐约束

> 加载器依据程序头表把 `PT_LOAD` 段从 `p_offset` 处拷贝/映射到 `p_vaddr`，再按 `p_flags` 设权限，然后跳到 `e_entry` 执行。

# 6）Section（简述）——链接器看什么

* 常见节：`.text`（代码）、`.rodata`（只读常量）、`.data`（已初始化数据）、`.bss`（未初始化数据，文件中不占空间）、`.symtab/.strtab`（符号/字符串表）、`.rel[a].*`（重定位）。
* **Section Header Table** 给出每个节的类型、大小、对齐、文件/内存位置等；链接器据此完成合并、重定位、符号解析。

# 7）把概念对上实践命令

* `file a.out`：快速识别是 32/64 位、大小端、是否动态/静态、是否 stripped。
* 生成可执行再转裸二进制（示例）：

  ```bash
  gcc -m32 -ffreestanding -fno-pie -c main.c -o main.o   # 产出 ET_REL
  ld  -m elf_i386 -Ttext 0x1500 -e main -o kernel.elf main.o  # 产出 ET_EXEC，含 ELF/Program Header
  objcopy -O binary kernel.elf kernel.bin  # 仅保留可装载内容 => 纯二进制
  ```

  * `kernel.elf` 用来调试（有头/符号/表）
  * `kernel.bin` 只有段内容，没有 ELF/表头，给引导程序直接装载

---

**一句话记忆**：
ELF 有“链接视图（sections/节头表）”和“执行视图（segments/程序头表）”；文件最前面是 ELF 头，告诉你两张“目录表”在哪。链接阶段看节，装载阶段看段。



`nm` = **显示目标文件/可执行文件中的符号表**，能帮你确认函数和变量的位置、类型，以及有没有未解析的引用。


### `wc -l`
**nm kernel.bin | wc -l**

- `wc` = word count（字/行统计）
    
- `-l` 选项表示统计 **行数**。
非常好的问题！你已经触及了操作系统加载过程中最核心、也最容易混淆的一个环节。你的三个问题问得非常好，我来为你逐一拆解。



#### loader 根据解析出来的信息，把缓冲区里的代码段、数据段等，分别拷贝到它们最终的目标内存地址

---


1.  **目标内存地址是虚拟地址吗？**
    * 链接时指定的地址 (`0xc0015000`) 是**虚拟地址**。
    * 但是，`loader` 在执行“拷贝”动作时，是把内核代码从一个**物理地址**（缓冲区 `0x70000`）拷贝到另一个**物理地址**（比如 `0x100000`）。

2.  **这个拷贝是什么意思？**
    * 它是一个纯粹的**内存数据复制** (`memcpy`)。就像在你的电脑上把一个文件从 C 盘的一个文件夹复制到另一个文件夹一样。`loader` 把内核的代码和数据，从内存中的临时“下载”位置，搬到最终的“安装”位置。

3.  **把目标虚拟地址映射到物理地址吗？**
    * **是的，但这发生在“拷贝”完成之后，跳转到内核之前。** “拷贝”本身只是搬运数据。搬运完成后，`loader` 最重要的工作之一就是设置页表，来建立这个**映射关系**。这是两个独立的步骤。

---

### 详细的执行流程分解

让我们把 `loader` 的工作流程放慢，看看每一步到底发生了什么。假设我们的内核很简单，只有一个代码段。

**背景**: `loader` 已经运行，并且把 `kernel.bin` 完整地加载到了**物理地址** `0x70000` 的缓冲区中。

1.  **【准备工作】 loader 进入保护模式**
    `loader` 首先会把自己从 16 位的实模式切换到 32 位的保护模式。这是后续所有操作的前提。

2.  **【解析】 loader 读取 ELF 头**
    `loader` 读取位于 `0x70000` 的 `kernel.bin` 的 ELF 程序头。它找到了一个 `PT_LOAD` 类型的段，并从程序头中读到了以下关键信息：
    * **虚拟地址 (`p_vaddr`)**: `0xc0015000`
    * **文件内偏移 (`p_offset`)**: 比如 1000 (表示代码段从文件的第 1000 个字节开始)
    * **大小 (`p_filesz`)**: 比如 8192 字节 (8KB)

3.  **【拷贝】 loader 搬运内核代码**
    `loader` 现在需要为这 8KB 的代码找一个最终的物理存放位置。一个最简单、最常见的选择就是**1MB 以上的第一个可用物理内存地址**。我们就假设 `loader` 决定把它放在物理地址 **`0x100000`** (也就是 1MB 的位置)。

    于是，`loader` 执行了一个内存拷贝操作：
    * **源地址**: `0x70000` (缓冲区基址) + `1000` (代码段在文件内的偏移) = **`0x71000`** (物理地址)
    * **目标地址**: **`0x100000`** (物理地址)
    * **拷贝长度**: 8192 字节

    执行完后，内核的代码段就静静地躺在**物理地址 `0x100000` 到 `0x101FFF`** 这片区域了。

    **关键点**：此时，代码虽然在物理地址 `0x100000`，但它内部所有的跳转、函数调用、地址引用都是基于 `0xc0015000` 编译的。如果你现在直接 `JMP 0x100000`，程序会立刻崩溃。

4.  **【映射】 loader 建立页表**
    这是最神奇的一步。为了让 CPU 能够正确执行位于 `0x100000` 的代码，`loader` 必须建立一个“地址翻译词典”（即页表）。

    `loader` 会在内存中创建页目录和页表，然后写入一条关键的映射规则：
    **“将虚拟地址 `0xc0015000` 映射到物理地址 `0x100000`”**

5.  **【激活与跳转】 loader 开启分页并移交控制权**
    * `loader` 将页目录的物理地址加载到 `CR3` 寄存器。
    * `loader` 设置 `CR0` 寄存器中的分页标志位，**正式开启分页机制**。从这一刻起，CPU 看到的所有地址都会被当作虚拟地址进行翻译。
    * 最后，`loader` 执行 `JMP 0xc0015000`。

    CPU 收到这个跳转指令后，MMU（内存管理单元）会介入：它查找页表，发现 `0xc0015000` 这个虚拟地址对应的是 `0x100000` 这个物理地址。于是，CPU 的指令指针就指向了**物理地址 `0x100000`**，内核的第一条指令被成功取出并执行。

### 生动的比喻

* **物理地址 `0x100000`**: 你新家的实际门牌号，“幸福路 123 号”。
* **虚拟地址 `0xc0015000`**: 你给新家起的名字，“我的理想乡”。
* **拷贝**: 搬家公司（`loader`）把你的家具从临时仓库（缓冲区 `0x70000`）搬到了新家“幸福路 123 号”。
* **映射 (页表)**: 你去邮局（设置 MMU）登记：“所有寄往‘我的理想乡’的信件，请全部送到‘幸福路 123 号’”。
* **跳转**: 你告诉朋友：“来‘我的理想乡’找我玩！” 朋友（CPU）根据邮局的登记信息，准确地找到了你的新家“幸福路 123 号”。

![[ELF程序头.png]]![[ELF文件头.png]]**readelf -l 的作用**

-l 表示 显示 Program Headers（也叫 segment headers）。

这个选项会把 ELF 文件的 程序头表 (Program Header Table, PHT) 打印出来，告诉你：

每个段 (Segment) 的类型 (Type，如 LOAD, DYNAMIC, INTERP 等)

段在文件中的偏移 (Offset)

映射到内存时的虚拟地址 (VirtAddr) 和物理地址 (PhysAddr)

文件中占用大小 (FileSiz) 和内存中占用大小 (MemSiz)

段的访问权限 (Flg → R/W/X)

对齐方式 (Align)



![[函数调用栈.png]]![[程序布局.png]]好的，这段文字描述的是 x86 保护模式下一个**极其重要且核心的安全机制**：**特权级切换时的栈切换**。

为了让您彻底明白，我将用一个比喻和分步解释来说明。

### 简单的比喻：去银行办事

想象一下这个场景：

- **你 (普通市民)** = **低特权级 (Ring 3) 的应用程序**。
    
- **你的钱包和记事本** = **应用程序的栈 (SS:ESP)**。这里面是你的私有数据。
    
- **银行金库 (安全区域)** = **高特权级 (Ring 0) 的内核**。
    
- **金库里专用的、干净的工作台** = **内核专用的栈 (由TSS提供)**。
    
- **银行柜员** = **CPU**。
    

你去银行办理一个需要进入金库才能处理的业务（比如提取大量现金）。

1. **你发起请求**：你（应用程序）通过一个特定的服务窗口（**系统调用**）向柜员（CPU）提出请求。
    
2. **柜员做交接准备 (进入高特权级)**：
    
    - 柜员**不能**把你的钱包和记事本（应用程序的栈）带进金库（内核），因为那是不安全的，可能会弄乱金库。
        
    - 于是，柜员在一个**专用的交接单**上，记下**你的名字**和你**钱包里有多少钱**（保存你应用程序的`SS`和`ESP`）。
        
    - 他把这张交接单放在**金库里那个干净的工作台**（内核栈）的**最上面**。
        
3. **柜员在金库工作**：柜员现在完全使用金库里的工作台（切换到内核栈）来处理你的业务。
    
4. **业务完成，交还给你 (返回低特权级)**：
    
    - 柜员处理完业务后，看到了放在工作台最上面的那张交接单。
        
    - 他根据交接单上的记录，准确地找到了你，并把你的钱包和记事本原封不动地还给你（通过`iret`指令恢复应用程序的`SS`和`ESP`）。你就可以继续做你自己的事了。
        

---

### 对文字的技术解释

现在我们用技术的语言来解释您截图中的那段话。

#### 第一段核心意思：为什么要切换栈，以及如何切换？

> “当处理器由低向高特权级转移时，它自动地把当时低特权级的栈地址 (SS 和 ESP) 压入了转移后的高特权级所在的栈中...”

- **为什么？**
    
    - **安全**：应用程序的栈 (Ring 3) 是不可信的。如果内核 (Ring 0) 也使用这个栈，应用程序可以通过一个恶意的栈指针让内核崩溃，或者窃取信息。
        
    - **可靠**：应用程序的栈可能很小，而内核执行复杂操作时可能需要更大的栈空间。
        
- **如何切换？(Ring 3 -> Ring 0)**
    
    1. 当应用程序通过**中断**或**调用门**请求内核服务时，CPU检测到特权级要提升。
        
    2. CPU会暂停应用程序，并自动去一个叫做 **TSS (Task State Segment)** 的特殊结构里查找**内核专用栈的地址**（即`SS0`和`ESP0`）。
        
    3. CPU将应用程序当前的栈指针 `SS` 和 `ESP` **压到**这个新的内核栈上。同时也会压入返回地址 `CS:EIP` 等信息。
        
    4. 最后，CPU将自己的 `SS` 和 `ESP` 寄存器更新为TSS里记录的内核栈地址。
        

> “所以，当用返回指令如 retf 或 iret 从高特权级向低特权级返回时，处理器可以从当前使用的高特权级的栈中获取低特权级的段选择子及偏移量。”

- **如何返回？(Ring 0 -> Ring 3)**
    
    - 内核代码执行完毕后，会调用 `iret` 指令。
        
    - 这个指令会触发一个逆向操作：CPU从当前内核栈的顶部，**弹出**之前保存的应用程序的 `SS`, `ESP`, `CS`, `EIP` 等，并把它们恢复到寄存器中。
        
    - 这一瞬间，CPU就从Ring 0安全地返回到了Ring 3，应用程序从它被中断的地方继续无缝执行。
        

#### 第二段核心意思：TSS中的栈指针是固定的，不会被更新

> “TSS 中栈指针值都是固定的，每次进入高特权级都会重复使用它们... 处理器也不会自动把该高特权级栈指针更新到 TSS 中”

这是另一个关键点，对应我们比喻里的“**金库里的工作台每天都会被清扫干净**”。

- `ESP0` 在TSS里存的**不是一个动态变化的指针**，而是一个**固定的栈顶地址**。
    
- 假设TSS里`ESP0`的值是`0x8000`。
    
    - 第一次系统调用发生时，`ESP`被设置为`0x8000`。内核在执行中可能会用掉一些栈空间，返回时`ESP`可能变成了`0x7F00`。
        
    - 当内核通过`iret`返回后，这个`0x7F00`的值**就被丢弃了**。
        
    - **下一次**再有系统调用发生时，CPU**仍然会从TSS中读取`0x8000`**，并将`ESP`再次设置为`0x8000`。
        
- **为什么这么设计？**
    
    - 这是一种**隔离机制**。它确保了每次系统调用都像是一次全新的、干净的进入。上一次系统调用如果把内核栈弄得一团糟（比如有内存泄漏），也不会影响到下一次系统调用，因为栈指针总是被重置到那个初始的、干净的位置。
        

> “如果想保留上一次高特权级的栈指针，咱们得自己手动更新 TSS 中相应栈的数据。”

- 这指的是在一些非常高级和特殊的设计（比如某些多任务内核）中，如果你确实需要保存内核栈的状态，那么操作系统内核需要自己写代码，手动去修改TSS里的值。CPU硬件**不会自动帮你做**这件事。

### TSS 即 Task State Segment
它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段
> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=243&annotation=8085R|当处理器进入不同的特权级时，它自 动在  TSS  中找同特权级的栈，你懂的，TSS  是处理器硬件原生的系统级数据结构，处理器当然知道  TSS 中哪些字段是目标栈的选择子及偏移量]]
是由 TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS 就成了

![[tss结构.png]]

**作用**
- 当程序需要从低权限的用户态 (Ring 3) 进入高权限的内核态 (Ring 0) 时（例如，发生系统调用或中断），CPU必须立即切换到一个安全、隔离的内核堆栈上，以防止用户程序破坏内核。

	这个专用的内核堆栈的地址（具体为 SS0 和 ESP0/RSP0）就预先存储在TSS中。CPU硬件会自动、强制性地从TSS里读取这个地址，并切换过去。可以说，TSS为CPU指明了通往内核安全工作区的路。

- 设定I/O端口的访问权限

	TSS内部可以包含一个“I/O许可位图”。操作系统可以通过修改这个位图，来精确授权某个用户态任务可以直接访问哪些硬件I/O端口。
	这个功能在虚拟化（如允许虚拟机直接访问某些硬件）和一些特殊的驱动程序中非常有用






### 门描述符
描述符同段描述符类似，都是 8 字节大小的数据结构，用来描述门中通向的代码。


> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=249&annotation=8140R|操作系统真象还原 (郑纲), p.249]]
> > 假设某调用门描述符位于 GDT 中第 1 个位置，这样的指令“call 0x0008：0x1234”，在调用此调用门时，偏移量 0x1234 会被 CPU 忽略
> 
> 
- **CPU执行指令**： CPU遇到指令 `call 0x0008:0x1234`。它看到这是一个远调用（far call）。
    
- **查找描述符**： CPU会拿着选择子（Selector）`0x0008` 去GDT（全局描述符表）中查找对应的描述符。
    
- **识别描述符类型**： 当CPU读取GDT中`0x0008`位置的描述符时，它会检查这个描述符的类型。此时它发现，这**不是一个普通的“代码段描述符”**，而是一个**“调用门描述符”（Call Gate Descriptor）**。
    
- **读取“门”内的信息**： 这个“调用门描述符”本身就是一个“路标”，它内部已经包含了**完整且固定**的目标地址信息：
    
    - 一个**目标代码段选择子**（指向真正要执行的代码所在的代码段，例如内核代码段）。
        
    - 一个**目标偏移地址**（指向该代码段内的某个特定入口点，例如内核函数的起始地址）。
        
- **执行跳转并忽略原偏移量**：
    
    - 因为CPU发现它要通过一个“门”进行跳转，它就会**完全采纳“门描述符”里记录的目标地址**。
        
    - 它会**丢弃** `call` 指令中提供的偏移量 `0x1234`。
        
    - 然后，CPU将“门”里指定的“目标代码段选择子”加载到 `CS` 寄存器，将“目标偏移地址”加载到 `EIP` 寄存器，完成跳转。


![[调用门描述符.png]]



> [!PDF|note] [[操作系统真象还原 (郑纲).pdf#page=251&selection=223,2,243,4&color=note|操作系统真象还原 (郑纲), p.251]]
> 其高 32 位的起始处有个“参数个数”，这是处理器将用户提供的参数复制给内核时需要用到的，参数在栈中的顺序是挨着的，所以处理器只需要知道复制几个参数就行了，这就是调用门描述符中“参数个数”的作用，它是专门给处理器准备的。该位是用 5 个 BIT 来表示的，所以最多可传递 31 个参数。

**call 指令调用“调用门”的完整过程**

**切换堆栈**：CPU识别出特权级变化，立刻根据TSS找到并加载新的内核堆栈。
- 触发切换： 您的用户程序（CPL=3）通过`int 0x80`或`syscall`指令发起系统调用。
- 确定目标： CPU发现这是一个要将特权级提升到 **Ring 0** 的操作。
- 查找TSS： CPU硬件通过 `TR` 寄存器找到当前TSS的位置。
- 读取新栈地址： 因为目标是 **Ring 0**，CPU会自动从TSS中读取 `SS0` 和 `ESP0` 的值。此时，CPU就拿到了“**新栈段选择子**”（来自SS0）和“新栈顶指针”（来自ESP0）。
- 执行安全检查（您上一个问题）： CPU拿到从`SS0`读出的**新栈段选择子**后，立刻去GDT中查找对应的描述符，并严格检查其 **DPL** 是否为0，以及 **TYPE** 是否为可写数据段。
- 切换栈： 如果检查通过，CPU将 `SS0` 的值加载到 `SS` 寄存器，将 `ESP0` 的值加载到 `ESP` 寄存器。就在这一瞬间，栈完成了从用户栈到内核栈的切换。

**保存现场**：为了能顺利返回，CPU在新的内核堆栈上，依次压入所有返回需要的信息，包括：
 - 旧的用户堆栈位置 (SS_old, ESP_old) 
 - 用户程序传递的参数（从用户栈复制而来）
 - 程序的返回地址 (CS_old, EIP_old)

		**跳转执行**：CPU加载调用门中指定的内核代码地址，正式开始在 Ring 0 执行内核服务。
**安全返回**：内核服务完成后，一条 retf 指令会触发逆向过程，CPU利用之前保存在内核堆栈上的信息，恢复所有现场，安全地返回到用户程序中断的地方继续执行。

![[特权级转移栈变化过程.png]]


**用 retf 指令从调用门返回的过程**
**第一步：判断返回类型**
CPU 执行 retf 时，首先会查看当前栈上保存的返回地址，特别是 CS（代码段选择子）。
它会读取这个 CS 选择子中的 RPL (请求者特权级)。这个 RPL 值代表了程序即将返回到的特权级。
CPU 将这个 RPL 与当前的 CPL (当前特权级) 进行比较。

**第二步：根据类型，执行两种不同的操作**
情况A：平级返回 ( RPL == CPL )
判定：这是一个在相同特权级内部的普通返回。
操作：CPU 只需从栈中弹出 EIP 和 CS，然后跳转到返回地址继续执行。过程非常简单。

情况B：跨级返回 ( RPL > CPL )
判定：这是一个从高特权级（如内核）向低特权级（如用户程序）的复杂返回。
操作：CPU 会执行一套更复杂、更安全的流程：
恢复堆栈：除了弹出 EIP 和 CS，还必须从栈中额外弹出 ESP 和 SS，以切换回原来低特权级的堆栈。
安全检查：检查 DS、ES 等数据段寄存器，防止它们在返回低特权级后，仍然指向高权限的内存数据，从而避免安全漏洞。

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=254&annotation=8154R|操作系统真象还原 (郑纲), p.254]]
> 如果在返回时需要改变特权级，**将会检查数据段寄存器 DS、ES、FS 和 GS 的内容**，如果在它们之中，某个寄存器中选择子所指向的数据段描述符的 DPL 权限比返回后的 CPL（CS.RPL）高，即数值上返回后的 CPL>数据段描述符的 DPL，处理器将把数值 0 填充到相应的段寄存器。


### RPL

> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=256&annotation=8157R|操作系统真象还原 (郑纲), p.256]]
> GDT、LDT 等全局系统数据表都是由操作系统构建的，只有操作系统知道表中段描述符、门描述符的索引，理所当然选择子也应该由操作系统构建，由操作系统分派给用户进程使用就行了。所以，一般情况下选择子都是由操作系统提供的，也就是说控制权在操作系统手里。**当用户程序请求操作系统服务，如果需要提交选择子作为参数，为安全起见，操作系统会把选择子中的 RPL 改为用户程序的 CPL**，为此，处理器还提供了修改 rpl 的相关指令


> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=256&annotation=8160R|操作系统真象还原 (郑纲), p.256]]
> 整个 4GB 内存是一个段，操作系统为所有用户进程构建了两个用户级的 RPL 为 3 的选择子，分别指向 4GB 的用户数据段和 4GB 的用户代码段。因为用户程序在自己的虚拟地址空间中运行，各用户进程的虚拟地址不冲突，所以各用户程序共用这两个选择子就够了，也就是说**用户进程在申请系统服务时无需提供选择子，从而，操作系统在系统服务程序内部就用这两个用户级的选择子便可以搞定一切。**

用户程序的 CPL 是由操作系统在加载用户程序时赋予的，记录在段寄存器 CS 中的低 2 位，就是 RPL 的位置，当它申请了系统服务，如果提交了选择子作为参数，选择子中的 RPL 也会被操作系统修改为用户进程的 CPL
***处理器的特权检查，都是只发生在往段寄存器中加载选择子访问描述符的那一瞬间***

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=259&annotation=8168R|操作系统真象还原 (郑纲), p.259]]
> 在该内核服务程序中，**操作系统将这个用户所提交的选择子的 RPL 变更为用户进程的 CPL**，也就是指向缓冲区所在段的选择子的 RPL 变成了 3。
-
**CPL 不在单独的寄存器里，始终等于当前 `CS` 段选择子的低 2 位。**
- 当从用户态（ring3）通过门进到内核（ring0）时，CPU 会做**特权级切换并把“旧现场”压到新栈（内核栈）**。  这个**被压到栈上的“旧 CS”**（以及旧 RIP、旧 SS、旧 RSP 等）里，**低 2 位就是调用者当时的 CPL=3**。  所以内核若想“知道调用者的 CPL”，读**内核栈上保存的旧 CS**就行：`caller_cpl = saved_cs & 0x3`。


#### 特权检查例子
##### 场景

- 进程在 **CPL=3**（用户态），想读到一项系统信息（在**内核数据段，DPL=0**）。
    
- OS 提供一个**调用门**（call gate），门的 **DPL=3**，目标是某内核服务例程所在的**非一致代码段**（DPL=0）。
    

##### 进入内核（通过调用门）

1. **门可达性检查**：要求 `max(CPL,RPL) ≤ 门.DPL`。  
    用户用的门选择子 RPL=3，CPL=3 → 允许使用该门。
    
2. **目标代码段检查**：门指向的段必须“可执行 + P=1”。（目标段 DPL=0）
    
3. **跨级动作**（因为从 3→0）：
    
    - **新 CPL = 目标段 DPL = 0**。
        
    - 硬件从 **TSS** 取 ring0 栈 → **切栈**。
        
    - 按门里的 **ParameterCount** 把旧栈上的 N 个参数**复制**到新栈。
        
    - 把**旧 SS:ESP、旧 CS:EIP**等压到新栈，以便 `lret` 返回。
        

##### 在内核中处理用户缓冲区指针

4. 用户把“**段选择子:偏移**”（指向用户缓冲区）当参数传上来。此选择子的 **RPL 是不可信的**（可能被伪造为 0）。
    
5. **内核先把这个选择子的 RPL 强制设为调用者的 CPL=3**（常用 `ARPL` 或直接把低两位置 11b）。  
    目的：让后续访问按**用户级**审查，防止“借内核之手”访问内核段。
    
6. 内核用该选择子把数据写回缓冲区时，数据段访问遵循：  
    **`DPL ≥ max(CPL, RPL)`**
    
    - 此时 `CPL=0`、`RPL=3` ⇒ 要求目标段 **DPL≥3**。
        
    - 若用户恶意把选择子指向 **内核段（DPL=0）**，检查失败，写入被硬件拒绝并触发异常；
        
    - 若确实指向 **用户段（DPL=3）**，检查通过，写入成功。
        
7. 若内核服务例程需要访问**内核自己的数据/代码**，则使用**RPL=0 的内核选择子**来访问（因为这些段 **DPL=0**）。
    

##### 返回用户态

8. 服务例程结束，用 **`lret`**（或对应快速路径 `sysret`）按新栈上保存的现场**降权返回**到用户态（`CPL=3`），继续执行。

##### jmp指令
- **近跳转（near jmp）**：只改 `EIP/RIP`，不换段、不换 CPL，当然也**不保存现场**（不压栈）。
    
- **远跳转（far jmp）到代码段描述符**：同时改 `CS:EIP`，做一次**特权检查**，但仍然**不保存返回地址**。
    
    - 目标是**非一致段（C=0）**：必须同级；规则等价于 **CPL = 目标段 DPL** 且 **RPL ≤ CPL**，因此 **不能借 jmp 改变 CPL**。
        
    - 目标是**一致段（C=1）**：允许进入但 **CPL 不变**（条件大致是 **CPL ≥ DPL**），同样**不能提权/降权**。
        
- **通过“门”**：
    
    - **JMP 不能用调用门（call gate）**，所以不能靠 jmp 受控“升权”。
        
    - **JMP 可以跳到任务门/TSS** → 触发**任务切换**；这时硬件会把当前任务现场保存到 TSS，再加载新任务的现场（这属于“换任务”，和“函数返回”概念不同）。
        
- **对比 CALL**：`CALL`（尤其 far call）会把返回地址（近 call 压 `IP`，远 call 压 `CS:IP`）压到栈上，日后 `RET/LRET` 能返回；而 `JMP` 没有这个步骤，因此**不可用 RET 返回**。
    

**JMP 的远转移能跨段，但不会像 CALL 那样保存返回点，也不能借此改变 CPL；只有 CALL 经过调用门或 `INT/SYSCALL` 这类“门”才能受控跨级。**


### IO 特权级
> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=260&annotation=8171R|操作系统真象还原 (郑纲), p.260]]
> IO  读写特权是由标志寄存器  eflags  中的  IOPL  位和  TSS  中的  IO  位 图决定的
![[eflags 寄存器.png]]
数值上CPL≤IOPL，程序既可以执行IO特权指令，又可以操作所有的IO端口。倘若数值上CPL > IOPL， 程序也不是完全无法进行任何 IO 操作,数值上 CPL > IOPL，则可以通过 IO 位图来设置部分端口的访问权限

I/O 位图只是在数值上 CPL > IOPL，即当前特权级比 IOPL 低时才有效，若当前特权级大于等于 IOPL，任何端口都可直接访问不受限制。**TSS 中I/O 位图可以存在，也可以不存在**,所以 TSS 的段界限 TSS limit，即实际大小-1， 并不固定。当 TSS 中不包括 I/O 位图时，TSS 只有 104 字节大小。

- ![[tss.png]]TSS 里有个 **“I/O 位图偏移”** 字段（相对 TSS 基址的偏移）。  
- 只有当这个偏移 **位于 [104, TSS limit]** 范围内时，才认为 **存在 IOPB**；否则视为**没有 IOPB**（TSS 最小长度 104 字节）。

- IOPB 的**最大长度**是 **8192 字节（=65536 位，对应全部 16 位端口空间）**，**后面必须再跟 1 个字节 `0xFF` 作为“哨兵/防越界字节”**。  

 - IOPB 的 TSS 实际大小是：**I/O 位图偏移 + 8192 + 1**（按需要也可更短，但末尾同样要有那 1 字节 `0xFF`）。
##### 为什么末尾一定要有 `0xFF`
1. **跨字节/越界检查的保险**  
    端口是**按字节编址**的。比如 `in ax, 0x234` 实际会访问 **0x234 和 0x235 两个字节端口**，CPU 必须检查这两个端口在位图里的两个 bit 都为 0 才放行。  
    如果某次访问跨过了你的位图末尾，CPU 会读到那 **最后的哨兵字节 `0xFF`** → 视为**禁止**，从而**不会**读到位图之外（TSS 之外）的内存。
    
2. **统一地“禁止超出位图覆盖的端口”**  
    你不想覆盖全部 65536 个端口时，位图之外的端口都会因为这个 `0xFF` 被**自动拒绝**，逻辑更简单、更安全。






## 完善内核

##### **栈帧基址**
`ESP` 是**栈顶指针**，每次 `push/pop` 都会变，**不稳定**；
'`EBP` 在函数内部保持不变，**稳定**，所以称它指向“栈帧基址/帧基址”。
“**栈帧基址**”就是：**被调用函数在进入时把 `EBP` 固定在本次调用这块栈区域的一个基准位置（通常是保存的旧 EBP 处），随后用 `[EBP+偏移]` 访问参数/返回地址，用 `[EBP-偏移]` 访问局部变量**
![[Pasted image 20250917214908.png]]
##### cdecl 调用约定
（1）调用者将所有参数从右向左入栈。 
（2）调用者清理参数所占的栈空间。


```
主调函数
1  push 2           ; 参数 b 入栈
2  push 3           ; 参数 a 入栈
3  call subtract    ; 调用函数 subtract
4  add esp, 8       ; 回收参数占用的栈空间 (cdecl 由调用者清理栈)

被调函数
1  push ebp           ; 保存调用者的 ebp
2  mov ebp, esp       ; 建立新栈帧，ebp = esp
3  mov eax,[ebp+0x8]  ; eax = 第1个参数 a
4  add eax,[ebp+0xc]  ; eax += 第2个参数 b
5  mov esp, ebp       ; 恢复 esp
6  pop ebp            ; 恢复调用者的 ebp
7  ret                ; 返回，并弹出返回地址
```


> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=270&annotation=8177R|操作系统真象还原 (郑纲), p.270]]
> 调用“系统调用”有两种方式。 
> （1）将系统调用指令封装为 c 库函数，通过库函数进行系统调用，操作简单。 
> （2）不依赖任何库函数，直接通过汇编指令 int 与操作系统通信。

> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=273&annotation=8180R|操作系统真象还原 (郑纲), p.273]]
> 在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字 extern。 y 在 C 代码中只要将符号定义为全局便可以被外部引用（一般情况下无需用额外关键字修饰，具体请参考 C 语言手册），引用外部符号时用 extern 声明即可


### 实现自己的打印函数
#### 显存
![[Pasted image 20250918220736.png]]![[Pasted image 20250918220755.png]]
**I/OAS (Input/Output Address Select) 的作用**
- 当 I/OAS = 0：
	CRT Controller Registers → 端口 3B4h/3B5h
	Input Status #1 → 3BAh
	Feature Control 写端口 → 3BAh
- 当 I/OAS = 1：
	CRT Controller Registers → 端口 3D4h/3D5h
	Input Status #1 → 3DAh
	Feature Control 写端口 → 3DAh
**默认情况下，Miscellaneous Output Register 的值为 0x67，即 I/OAS = 1，使用 彩色/graphics**

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=284&annotation=8183R|操作系统真象还原 (郑纲), p.284]]
> 用户进程是需要用  iretd  返回指令上  CPU  运行的，这些以后会说的， 大家暂且接受这个结论。CPU  在执行  iretd  指令时会做特权检查，它检查  DS、ES、FS、GS“数据”段寄存器的 内容，这里的数据我加了引号，它只是修饰段寄存器的定语，用来指除代码段寄存器  CS  和栈段寄存器  SS  之外 的段寄存器。在  32  位保护模式下它们中存储的都是选择子，要是有任何一个段寄存器所指向的段描述符的  DPL 权限高于从  iretd  命令返回后的  CPL（这个返回后的  CPL  也就是新的  CPL，CPL  就是加载到  CS  寄存器中选择子 的  RPL），CPU  就会将该段寄存器赋值为  0。
**用户进程的特权级由 CS 寄存器中选择子的 RPL 字段决定，它将成为进程在 CPU 上运行时的 CPL**
