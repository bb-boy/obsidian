## **BIOS
### 1. **BIOS的作用和存放位置**

- **作用**：BIOS（Basic Input/Output System）是计算机加电后运行的第一段程序，负责**硬件的自检和初始化**，以及后续操作系统引导的准备工作。
- **存放位置**：BIOS固化在**主板上的ROM芯片**里。ROM（只读存储器）断电后数据不会丢失，非常适合存储“启动时必须有”的程序代码。

---

### 2. **BIOS的入口和实模式寻址**

- **入口地址**：CPU复位后，会自动跳到物理地址`0xFFFF0`处执行BIOS（其实这只是BIOS映像的末尾，实际只放一个跳转指令）。
- **CS:IP寻址机制**：实模式下，CS:IP（代码段:指令指针）组合起来可以寻址20位物理地址，即`(CS << 4) + IP`。例如启动时CS=0xF000, IP=0xFFF0，最终地址就是`0xFFFF0`。
- **跳转原理**：`0xFFFF0`只存了一个“跳转指令”，实际BIOS代码在别处，比如`0xFE05B`。

---

### 3. **BIOS初始化及中断向量表**

- BIOS会对**内存、显卡、键盘等外设做自检**和初始化，还要给后续系统引导做准备。
- BIOS最重要的工作之一：**建立中断向量表（Interrupt Vector Table, IVT）**。
    - 位置：实模式下，**中断向量表位于内存0x0000 ~ 0x03FF**（即前1KB空间）。
    - 作用：存放256个中断类型（0~255，每个4字节），每个中断的入口地址，也就是“向量”。
    - 这样，CPU遇到`int xx`指令（如`int 0x80`），就能从IVT查到处理该中断的函数地址，快速跳转过去执行对应服务。

---

### 4. **BIOS到MBR的流程梳理**

- BIOS初始化硬件
- 建立中断向量表
- 加载并跳转到**MBR（主引导记录）**，为操作系统启动做准备

---
## **BIOS的最后一项任务**

- **检测磁盘**：BIOS会去检查“0盘0道1扇区”（即第一个硬盘的第一个柱面、第一扇区）内容。
- **历史原因**：扇区编号从1开始，所以“1扇区”其实是第一个扇区，不用纠结。

## 2. **MBR的“魔数”检测**

- **魔数**：BIOS会检查这个扇区最后两个字节（第511字节和第512字节）。
    - 必须分别为`0x55`和`0xAA`（小端序存储，其实在内存中是`0xAA55`）。
- **作用**：这是一种“标记”，告诉BIOS“这是一个有效的启动扇区（可引导扇区）”。

## 3. **MBR的加载位置和执行**

- **加载位置**：如果检测到魔数，BIOS会把整个512字节的MBR代码加载到**内存的物理地址0x7C00**处。
- **跳转执行**：接着CPU会跳转到0x7C00，开始执行MBR里的引导程序（这也是我们写自制操作系统时第一个能“跑起来”的自己的代码）。

## 4. **MBR相关规定**

- **大小**：MBR固定为**512字节**。
- **末尾魔数**：第511字节和第512字节必须是`0xAA`、`0x55`（用小端序存储，实际为`0x55AA`）。
- **内容**：前446字节通常存放引导程序代码，接着64字节是分区表，最后2字节是魔数。
- **小端序**：因为x86平台是小端序，所以存储顺序是低字节在前（即`0x55`，再是`0xAA`）。

![[image.png]]![[Pasted image 20250828145854.png]]

## 保护模式入门
开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

---

根据您提供的信息，这是一个关于 **全局描述符表 (GDT)** 的描述，可以总结如下：

---


### 全局描述符表 (Global Descriptor Table, GDT)

- **本质**: 全局描述符表是一个储存在内存中的“表”，它由一系列被称为 **段描述符** 的表项组成。
    
- **表项 (段描述符)**: 表中的每一个条目都称为一个段描述符，其大小为 **64 字节**。每个段描述符都用来详细描述一个内存段，包括它的**起始地址**、**大小**和**访问权限**等信息。
    
- **存放位置与引用**: 由于该表可能非常大，因此它被存放在内存中。处理器使用 **GDTR 寄存器** 来指向该表的起始位置，从而能够找到并访问它。
    

简而言之，全局描述符表就像一个目录，列出了所有可用的内存段，而 GDTR 寄存器则像一个指针，指向这个目录的起点，让处理器可以快速找到它。

---

### 1. 从实模式到保护模式的转变

在实模式下，CPU（如 8086）直接使用**段基址**和**偏移地址**计算出物理地址。

- **实模式（16 位）**：
    
    - 段寄存器中存放的是**段基址**。
        
    - 物理地址 = **段基址**左移 4 位 + **偏移地址**。
        
    - 每次访问都需进行计算，效率较低。
        

在保护模式下，为了增强安全性和灵活性，段寄存器不再直接存储段基址。

- **保护模式（32 位及以上）**：
    
    - 段寄存器中存放的是**选择子**（selector）。
        
    - **选择子**用作**索引**，指向内存中的**全局描述符表 (GDT)**。
        
    - **全局描述符表 (GDT)** 中存储着一个个**段描述符**。
        
    - **段描述符**包含了内存段的**起始地址、大小、权限**等详细信息。
        

---

### 2. 引入段描述符缓冲寄存器

由于每次访问内存都去 GDT 中查找段描述符效率很低，保护模式引入了**段描述符缓冲寄存器**，这是一个对程序员**不可见**的硬件缓存。

**工作原理：**

1. 当段寄存器被加载一个新的**选择子**时，CPU 会从 GDT 中获取完整的段描述符信息。
    
2. CPU 将这些信息整理并存入对应的**段描述符缓冲寄存器**中。
    
3. 此后，只要段寄存器不改变，CPU 就会直接从这个**缓存寄存器**中读取段信息，从而大大提高访问效率。
    

**该缓存的失效机制是：**

- 只要对段寄存器进行**赋值**（即使赋了相同的值），CPU 都会重新从 GDT 中获取并更新缓存寄存器。
    

---

### 3. 段描述符缓冲寄存器的兼容性

虽然段描述符缓冲寄存器是为保护模式设计的，但它也可以用在实模式下，以提高效率。

- **在实模式下**：当段寄存器被赋值时，段基址左移 4 位后的结果会被存入段描述符缓冲寄存器。此后，只要段寄存器不变，CPU 都会直接从缓存中获取计算好的地址，避免重复计算。![[Pasted image 20250828153135.png]]![[Pasted image 20250828154726.png]]![[Pasted image 20250828161946.png]]![[Pasted image 20250828162000.png]]
- - **`0x66`**：用于反转**数据本身**的大小（例如，`word` ↔ `dword`，即 16 位 ↔ 32 位）。
    
- **`0x67`**：用于反转**计算内存地址方式**的大小（例如，用 16 位寄存器 `[bx]` 寻址 ↔ 用 32 位寄存器 `[eax]` 寻址）。
mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。 其中“寄存器/内存”是乘数。 如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。 如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。 如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积 的高 32 位，eax 是积的低 32 位
对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。 如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。 如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于 寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。 如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于 寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。