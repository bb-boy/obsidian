## **BIOS
### 1. **BIOS的作用和存放位置**

- **作用**：BIOS（Basic Input/Output System）是计算机加电后运行的第一段程序，负责**硬件的自检和初始化**，以及后续操作系统引导的准备工作。
- **存放位置**：BIOS固化在**主板上的ROM芯片**里。ROM（只读存储器）断电后数据不会丢失，非常适合存储“启动时必须有”的程序代码。

---

### 2. **BIOS的入口和实模式寻址**

- **入口地址**：CPU复位后，会自动跳到物理地址`0xFFFF0`处执行BIOS（其实这只是BIOS映像的末尾，实际只放一个跳转指令）。
- **CS:IP寻址机制**：实模式下，CS:IP（代码段:指令指针）组合起来可以寻址20位物理地址，即`(CS << 4) + IP`。例如启动时CS=0xF000, IP=0xFFF0，最终地址就是`0xFFFF0`。
- **跳转原理**：`0xFFFF0`只存了一个“跳转指令”，实际BIOS代码在别处，比如`0xFE05B`。

---

### 3. **BIOS初始化及中断向量表**

- BIOS会对**内存、显卡、键盘等外设做自检**和初始化，还要给后续系统引导做准备。
- BIOS最重要的工作之一：**建立中断向量表（Interrupt Vector Table, IVT）**。
    - 位置：实模式下，**中断向量表位于内存0x0000 ~ 0x03FF**（即前1KB空间）。
    - 作用：存放256个中断类型（0~255，每个4字节），每个中断的入口地址，也就是“向量”。
    - 这样，CPU遇到`int xx`指令（如`int 0x80`），就能从IVT查到处理该中断的函数地址，快速跳转过去执行对应服务。

---

### 4. **BIOS到MBR的流程梳理**

- BIOS初始化硬件
- 建立中断向量表
- 加载并跳转到**MBR（主引导记录）**，为操作系统启动做准备

---
### **BIOS的最后一项任务**

- **检测磁盘**：BIOS会去检查“0盘0道1扇区”（即第一个硬盘的第一个柱面、第一扇区）内容。
- **历史原因**：扇区编号从1开始，所以“1扇区”其实是第一个扇区，不用纠结。

## **MBR的“魔数”检测**

- **魔数**：BIOS会检查这个扇区最后两个字节（第511字节和第512字节）。
    - 必须分别为`0x55`和`0xAA`（小端序存储，其实在内存中是`0xAA55`）。
- **作用**：这是一种“标记”，告诉BIOS“这是一个有效的启动扇区（可引导扇区）”。

##  **MBR的加载位置和执行**

- **加载位置**：如果检测到魔数，BIOS会把整个512字节的MBR代码加载到**内存的物理地址0x7C00**处。
- **跳转执行**：接着CPU会跳转到0x7C00，开始执行MBR里的引导程序（这也是我们写自制操作系统时第一个能“跑起来”的自己的代码）。

##  **MBR相关规定**

- **大小**：MBR固定为**512字节**。
- **末尾魔数**：第511字节和第512字节必须是`0xAA`、`0x55`（用小端序存储，实际为`0x55AA`）。
- **内容**：前446字节通常存放引导程序代码，接着64字节是分区表，最后2字节是魔数。
- **小端序**：因为x86平台是小端序，所以存储顺序是低字节在前（即`0x55`，再是`0xAA`）。

<<<<<<< HEAD
![[操作系统/shot/image 1.png]]![[计算机启动流程.png]]


## 保护模式入门
开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
寄存器中低 16 位的部分是为了兼容实模式，可以单独使用。高 16 位没办法单独使用，只能在用 32 位寄存器时才有机会用到它们。

---



## 全局描述符表 (Global Descriptor Table, GDT)

- **本质**: 全局描述符表是一个储存在内存中的“表”，它由一系列被称为 **段描述符** 的表项组成。
    
- **表项 (段描述符)**: 表中的每一个条目都称为一个段描述符，其大小为 **64 字节**。每个段描述符都用来详细描述一个内存段，包括它的**起始地址**、**大小**和**访问权限**等信息。
    
- **存放位置与引用**: 由于该表可能非常大，因此它被存放在内存中。处理器使用 **GDTR 寄存器** 来指向该表的起始位置，从而能够找到并访问它。
    

简而言之，全局描述符表就像一个目录，列出了所有可用的内存段，而 GDTR 寄存器则像一个指针，指向这个目录的起点，让处理器可以快速找到它。

---

### 1. 从实模式到保护模式的转变

在实模式下，CPU（如 8086）直接使用**段基址**和**偏移地址**计算出物理地址。

- **实模式（16 位）**：
    
    - 段寄存器中存放的是**段基址**。
        
    - 物理地址 = **段基址**左移 4 位 + **偏移地址**。
        
    - 每次访问都需进行计算，效率较低。
        

在保护模式下，为了增强安全性和灵活性，段寄存器不再直接存储段基址。

- **保护模式（32 位及以上）**：
    
    - 段寄存器中存放的是**选择子**（selector）。
        
    - **选择子**用作**索引**，指向内存中的**全局描述符表 (GDT)**。
        
    - **全局描述符表 (GDT)** 中存储着一个个**段描述符**。
        
    - **段描述符**包含了内存段的**起始地址、大小、权限**等详细信息。
        

---

### 2. 引入段描述符缓冲寄存器

由于每次访问内存都去 GDT 中查找段描述符效率很低，保护模式引入了**段描述符缓冲寄存器**，这是一个对程序员**不可见**的硬件缓存。

**工作原理：**

1. 当段寄存器被加载一个新的**选择子**时，CPU 会从 GDT 中获取完整的段描述符信息。
    
2. CPU 将这些信息整理并存入对应的**段描述符缓冲寄存器**中。
    
3. 此后，只要段寄存器不改变，CPU 就会直接从这个**缓存寄存器**中读取段信息，从而大大提高访问效率。
    

**该缓存的失效机制是：**

- 只要对段寄存器进行**赋值**（即使赋了相同的值），CPU 都会重新从 GDT 中获取并更新缓存寄存器。

---

### 3. 段描述符缓冲寄存器的兼容性

虽然段描述符缓冲寄存器是为保护模式设计的，但它也可以用在实模式下，以提高效率。

- **在实模式下**：当段寄存器被赋值时，段基址左移 4 位后的结果会被存入段描述符缓冲寄存器。此后，只要段寄存器不变，CPU 都会直接从缓存中获取计算好的地址，避免重复计算。![[不同模式段寄存器作用.png]]![[机器码格式.png]]![[不用模式下寻址方式.png]]![[不用模式下反转指令.png]]
**mul** 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。 其中“寄存器/内存”是乘数。 如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。 如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。 如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积 的高 32 位，eax 是积的低 32 位
**对于无符号数除法指令 div**，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。 如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。 如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于 寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。 如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于 寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

- **`BYTE` (字节)**: 8 位
    
- **`WORD` (字)**: 16 位
    
- **`DWORD` (Double Word, 双字)**: 32 位
    
- **`QWORD` (Quad Word, 四字)**: 64 位
- - **在16位模式（如实模式）下**：CPU 默认处理的数据单元是 16 位的，也就是一个 **`WORD`**。
    
- **在32位保护模式下**：CPU 最高效、最自然处理的数据单元是 32 位的，也就是一个 **`DWORD`**。

**`0x66`**：用于反转**数据本身**的大小（例如，`word` ↔ `dword`，即 16 位 ↔ 32 位）。
**`0x67`**：用于反转**计算内存地址方式**的大小（例如，用 16 位寄存器 `[bx]` 寻址 ↔ 用 32 位寄存器 `[eax]` 寻址）。

**`0x66`前缀的明确作用**：正如我们之前讨论的，保护模式的默认操作数是32位。当你执行一条16位的压栈指令（例如 `push ax`）时，汇编器会在机器码前加上 `0x66` 这个“操作数大小反转前缀”。这个前缀的作用就是明确地告诉CPU：“**注意！接下来的这条指令，请把操作大小从默认的32位临时切换为16位！**” 因此，CPU收到的命令不是“压入一个值”，而是“**执行一次16位的压栈操作**”，所以它只会移动16位数据，并将栈指针`esp`减2。
当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针 减 4。 当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。 当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。
### 全局描述符表（Global Descriptor Table，GDT）

是保护模式下内存段的登记表
![[段描述符.png]]：段界限 (Segment Limit)

1. **基本定义**: 段界限是存放在**段描述符**中的一个 **20 位**数值，它用来规定一个内存段的**大小或边界**。
    
2. **粒度 (Granularity) - G位决定单位**: 这个 20 位的段界限值本身不是最终大小，它需要乘以一个“单位”或“粒度”，这个粒度由段描述符中的 **G 位** 决定：
    
    - **G = 0**: 粒度为 **1 字节**。段的最大尺寸可以达到 220 字节，即 **1 MB**。
        
    - **G = 1**: 粒度为 **4 KB**。段的最大尺寸可以达到 220×4KB=232 字节，即 **4 GB**。
        
3. **精确的边界计算公式**: 要计算段内最后一个可访问地址的偏移量（即实际段边界），需要使用以下公式：
    
    实际边界=(描述符中的段界限+1)×粒度−1
    
    - **为什么要 `+1`**：因为描述符中的20位段界限是从0开始的计数。`0xFFFFF` 代表 `0x100000` 个单位。
        
    - **为什么要 `× 粒度`**：将单位数量转换成实际的字节总数。
        
    - **为什么要 `-1`**：因为内存地址是从0开始的。一个大小为N字节的段，其合法的偏移范围是 `0` 到 `N-1`。
        
    
    **示例 (平坦模型)**:
    
    - 段界限字段 = `0xFFFFF`，G位 = `1` (粒度为 4KB, 即 `0x1000` 字节)
        
    - 实际边界 = (`0xFFFFF` + 1) * `0x1000` - 1
        
    - = `0x100000` * `0x1000` - 1
        
    - = `0x100000000` - 1
        
    - = `0xFFFFFFFF` (这覆盖了全部 4GB 内存空间)
        
4. **扩展方向**: 段界限的意义取决于段的类型：
    
    - **向上扩展 (代码段/数据段)**：段界限定义了段内**最大**的有效偏移。合法访问范围是 `0` 到 `实际边界`。
        
    - **向下扩展 (栈段)**：段界限定义了段内**最小**的有效偏移。地址向下增长（`push` 操作使地址变小）。
### 段描述符结构总结

1. **分段的基地址 (Base Address) 是“碎片化”存储的**： 一个完整的 32 位段基地址并不是连续存放在一起的，而是被拆分成了 **三部分**，分散在 64 位的段描述符中：
    
    - **第一部分 (0-15位)**：存放在描述符的**低32位**中。
        
    - **第二部分 (16-23位)**：存放在描述符的**高32位**中。
        
    - **第三部分 (24-31位)**：也存放在描述符的**高32位**中。 在解析一个段描述符时，需要将这三部分拼接起来才能得到完整的32位基地址。
        
2. **S 位：决定描述符的根本性质 (系统 vs. 非系统)**： 段描述符中的 **S 位 (Descriptor Type bit)** 是一个关键的开关，它将描述符分为两大类：
    
    - **S = 0：系统段 (System Segment)**
        
        - 供**硬件**直接使用，用于管理系统级的结构。
            
        - 典型的例子是各种“门”（Gate），如调用门、任务门，它们是硬件定义的程序入口点。
            
    - **S = 1：非系统段 (Code or Data Segment)**
        
        - 供**软件**（包括操作系统和应用程序）使用。
            
        - 从CPU的角度看，无论是**代码、数据还是栈**，都是提供给硬件处理的“数据”，因此它们都属于这一类。
            
3. **Type 字段：依赖 S 位进行精细分类**：
    
    - **Type 字段**是一个 4 位的区域，用来进一步指明段的具体类型（如只读数据、可执行代码等）。
        
    - **关键点**：Type 字段的**具体含义完全取决于 S 位的值**。只有先确定了是系统段（S=0）还是非系统段（S=1），Type 字段中的值才能被正确解读。
        

**一句话总结：** 段描述符通过**S位**来区分是为硬件服务的“系统段”还是为软件服务的“代码/数据段”，然后再结合 **Type 字段**来明确其具体用途。而段的32位起始地址则需要从描述符的三个不同位置读取并组合而成。
![[段描述符高32位.png]] **Type 字段 (Bits 11-8) 的内部标志位**

`Type` 字段本身由几个独立的标志位组成，用于描述**非系统段（S=1时）**的详细属性：

- **A (Accessed)**: **访问位**。段被CPU访问后，此位由CPU自动置1。
    
- **X (eXecutable)**: **可执行位**。`1`表示代码段，`0`表示数据段。
    
- **E (Extend-direction)**: **扩展方向位**。
    
    - `0` = **向上扩展** (用于代码/数据段，地址由低到高)。
        
    - `1` = **向下扩展** (用于栈段，地址由高到低)。
        
- **W (Writable) / R (Readable)**: **可写/可读位**。
    
    - **数据段**中，此位是 **W**。`1`=可写，`0`=只读。
        
    - **代码段**中，此位是 **R**。`1`=可读，`0`=不可读（但仍可执行）。
        
- **C (Conforming)**: **一致性代码段位**。用于代码段，决定特权级转移的规则。

---

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里。这个专门的寄存器便是 GDTR， 即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器![[GDT寄存器.png]]

- **加载GDT：使用 `lgdt` 指令**
    
    - **专用指令**: 不能使用`mov`等通用指令来设置全局描述符表寄存器(GDTR)，必须使用专用的 `lgdt` 指令。
        
    - **操作数格式**: `lgdt` 指令需要一个 48 位的内存地址作为操作数，这48位数据包含两部分：
        
        - **前16位**: GDT 表的**界限 (Limit)**，即 GDT 的总字节大小减 1。
            
        - **后32位**: GDT 表的**起始物理地址 (Base Address)**。
            
    - **使用时机**: 该指令既可以在**实模式**下执行（为进入保护模式做准备），也可以在**保护模式**下再次执行（用于重新定位或更换GDT）。
        
- **GDT的容量**
    
    - 由于 `lgdt` 指令中的界限字段是 16 位，所以GDT本身最大为 216 = 65536 字节（64 KB）。
        
    - 每个段描述符固定占用 8 字节。
        
    - 因此，一个GDT中最多可以容纳 65536 / 8 = **8192 个描述符**。
        
- **保护模式下的段寄存器：内容变为“段选择子” (Selector)**
    
    - **根本性转变**: 段寄存器（CS, DS, SS等）的用途发生了根本改变。
        
    - **实模式下**: 段寄存器存放的是**段基地址**。
        
    - **保护模式下**: 段基地址等信息已经存入了GDT的描述符中。段寄存器不再存放基地址，而是存放一个称为 **“选择子” (Selector)** 的值。
        
    - **选择子的作用**: 选择子本质上是一个**索引**，它指向GDT中的某一个具体的段描述符。CPU通过这个“索引”去GDT中找到对应的“身份证”（段描述符），从而获取到该段的基地址、界限、权限等所有信息。
### 段选择子 (Selector) 总结

1. **定义与用途**: 在保护模式下，16位的段寄存器（如 CS, DS）中存放的不再是段基地址，而是一个16位的 **段选择子 (Selector)**。它的核心作用是作为**索引**，用于在描述符表（GDT或LDT）中**定位**一个具体的段描述符。
    
2. **16位结构拆解**: 一个选择子被精确地划分为三个部分：![[选择子.png]]
3. **工作流程与最终目的**: 尽管保护模式的内存访问机制变了，但最终形式上依然是 **“段基址 : 段内偏移地址”**。这个过程由CPU自动完成：

	1. CPU从段寄存器中获取**选择子**。
	    
	2. 使用选择子中的 **TI位** 确定是在GDT还是LDT中查找。
	    
	3. 使用选择子中的 **Index** 在该表中找到对应的段描述符。
	    
	4. CPU**自动从段描述符中取出32位的段基地址**。
	    
	5. 将这个基地址与指令中的**段内偏移地址**相加，最终形成要访问的线性地址。

**GDT 中的第 0 个段描述符是不可用的，原因是定义在 GDT 中的段描 述符是要用选择子来访问的，如果使用的选择子忘记初始化，选择子的值便会是 0，这便会访问到第 0 个 段描述符**

[[`在 x86 架构中，当计算机启动时，CPU 处于实模式（Real Mode），并且所有段寄存器（包括 cs）都被初始化为特定的值。具体来说，cs 被设置为 0xf000，而指令指针 ip 被设置为 0xfff0。这意味着 CPU 启动时的地址是 0xffff0（cs << 4 + ip = 0xf0000 + 0xfff0 = 0xffff0）。`

`BIOS 的入口点通常位于这个地址附近。BIOS 会执行一系列初始化操作，然后将主引导记录（MBR）加载到内存地址 0x7c00 处，并将 cs 设置为 0x0000，ip 设置为 0x7c00，从而使 CPU 跳转到 MBR 代码开始执行。`]]



## 保护模式式进阶



### 内存检测

---

#### **方法一：`AH = 0x88` 功能**

这是最古老、最简单的一种方法。

- **核心功能：** 获取大于1MB的扩展内存大小。
    
- **使用方法：**
    
    1. 将`AH`寄存器设置为`0x88`。
        
    2. 调用`int 0x15`中断。
        
- **结果解读：**
    
    - 中断返回后，`AX`寄存器中的值就是**以KB为单位**的内存容量（不包含低端1MB）。
        
    - **总内存 ≈ AX * 1024 + 1MB**。
        
- **优点：**
    
    - 调用非常简单，一行汇编指令即可。
        
- **缺点：**
    
    - **有64MB的上限。** 这是它最致命的弱点。无论系统实际有多少内存，此功能最多返回64MB（减去1MB后对应的值）。对于现代计算机来说，这个方法基本已经过时。
        

---

#### **方法二：`AX = 0xE801` 功能**

这是一个过渡时期的增强方法，比`AH=0x88`更强大，但仍有局限。

- **核心功能：** 分段检测内存，最高可支持到4GB。
    
- **使用方法：**
    
    1. 将`AX`寄存器设置为`0xE801`。
        
    2. 调用`int 0x15`中断。
        
- **结果解读：**
    
    - 中断返回后，结果被分成了两部分存放在不同的寄存器中：
        
        - `AX` (或 `CX`): 存放**1MB到16MB之间**的内存大小，单位是**KB**。
            
        - `BX` (或 `DX`): 存放**16MB以上**的内存大小，单位是**64KB**。
            
    - **总内存 ≈ (AX * 1KB) + (BX * 64KB) + 1MB**。
        
- **优点：**
    
    - 相比`AH=0x88`，检测上限大大提高，能处理4GB以内的内存。
        
- **缺点：**
    
    - **检测结果不直观**，需要拼接两部分结果。
        
    - **仍然有4GB的上限**，无法应对超过4GB内存的64位系统。
        
    - **可能不完全准确**，无法识别出内存中可能存在的“空洞”（被硬件保留的地址段）。
        

---

#### **方法三：`EAX = 0xE820` 功能 (现代标准方法)**

这是目前最强大、最准确、也是现代操作系统和引导加载程序**唯一推荐使用**的方法。它返回的不是一个简单的总容量，而是一个完整的**系统内存布局图（Memory Map）**。

- **核心功能：** 获取一个由**地址范围描述符（Address Range Descriptor Structure, ARDS）**组成的列表，详细描述了系统中所有内存段的起始地址、长度和类型。
    
- **使用方法：**
    
    - 这是一个**循环调用**的过程。
        
    
    1. **首次调用：** 将`EAX`设为`0xE820`，`EBX`设为`0`，`EDX`设为魔数`0x534D4150` ('SMAP')，并让`ES:DI`指向一个足够大的缓冲区（至少20字节）。
        
    2. 调用`int 0x15`。
        
    3. **后续调用：** 如果上一次调用成功（`CF`标志位为0且`EBX`不为0），则将返回的`EBX`值作为下一次调用的输入，再次调用`int 0x15`，直到`EBX`返回0为止。
        
- **结果解读：**
    
    - 每次成功调用后，`ES:DI`指向的缓冲区会被填充一个**ARDS**结构，该结构包含：
        
        - **BaseAddr (64位):** 内存段的起始地址。
            
        - **Length (64位):** 内存段的长度（以字节为单位）。
            
        - **Type (32位):** 内存段的类型（例如，Type 1是可用内存，Type 2是保留内存，不可使用）。
            
    - 通过遍历所有ARDS，将所有**Type为1（可用）**的内存段的长度相加，就能得到最准确的可用物理内存总量。
        
- **优点：**
    
    - **极其准确和全面：** 能识别所有内存区域，包括不连续的内存和“空洞”。
        
    - **没有容量上限：** 支持64位地址空间，可以检测任意大小的内存。
        
    - **提供详细信息：** 不仅知道有多大内存，还知道这些内存在哪里、是否可用。
        
- **缺点：**
    
    - **实现最复杂：** 需要编写循环，并解析返回的数据结构。
        

---

#### **总结对比**

| 特性         | 方法一 (`AH=0x88`) | 方法二 (`AX=0xE801`) | 方法三 (`EAX=0xE820`)  |
| ---------- | --------------- | ----------------- | ------------------- |
| **功能码**    | `AH = 0x88`     | `AX = 0xE801`     | `EAX = 0xE820`      |
| **最大检测容量** | 64MB            | 4GB               | 无实际限制 (64位)         |
| **返回信息**   | 1MB以上的总容量 (KB)  | 两段式的容量 (KB和64KB块) | 详细的**内存布局图 (ARDS)** |
| **实现复杂度**  | **非常简单**        | 简单                | **复杂** (需要循环和解析)    |
| **准确性**    | 低，有硬上限          | 中等，无法识别内存空洞       | **非常高**，最可靠         |
| **推荐度**    | 已过时，不推荐         | 过渡方案，不推荐          | **现代系统唯一推荐**        |



### 1. CF标志位的“双重身份”

CPU中的标志寄存器（FLAGS/EFLAGS）有很多位，每一位都有特定的含义。**进位标志位（CF）**有两个主要作用：

1. **本职工作（硬件层面）：** 在执行**算术运算**时，CF用来表示无符号数的溢出。例如，一个8位的数`11111111`加1后，结果是`00000000`，但CF位会被置为1，表示“有进位产生”。在减法中，它充当“借位”标志。
    
2. **兼职工作（软件层面）：** 正是因为CF是一个很容易被设置（置1）或清除（清0）的独立标志位，早期的系统程序员们（比如设计IBM PC BIOS和MS-DOS的那些人）就**约定**用它来作为一个通用的**函数调用成功/失败的信号**。


---

### **`jc` (Jump on Carry) - 如果有进位则跳转**

- **完整名称：** Jump on Carry / 如果进位则跳转
    
- **检查的标志位：** **CF (Carry Flag / 进位标志位)**
    
- **跳转条件：** 当 `CF = 1` 时，执行跳转。
    

**`jc` 主要用于以下场景：**

1. 检查无符号数运算是否溢出或借位：
    
    这是CF标志位的本职工作。
    
    - **加法溢出：** 两个无符号数相加，结果超出了寄存器能表示的最大范围。
        
        代码段
        
        ```
        mov al, 0xFF  ; AL = 255
        add al, 1     ; 255 + 1 = 256, 超出8位范围, 结果AL=0, CF=1
        jc overflow_handler ; CF=1, 所以会跳转
        ```
        
    - **减法借位：** 一个小的无符号数减去一个大的无符号数。
        
        代码段
        
        ```
        mov al, 5
        sub al, 10    ; 5 - 10, 需要借位, 结果AL=251, CF=1
        jc borrow_handler ; CF=1, 所以会跳转
        ```
        
2. **检查BIOS或系统调用的失败信号：**
    
    - 正如我们之前讨论的，很多BIOS和DOS中断服务，**约定使用 `CF=1` 来表示调用失败**。`jc` 正是用来捕获这种失败信号的指令。
        
        代码段
        
        ```
        mov eax, 0xe820
        int 0x15
        jc bios_call_failed ; 如果BIOS调用失败(CF=1), 则跳转到错误处理
        ```
        
3. **检查位操作移出的比特：**
    
    - 在移位指令（如`shl`, `shr`）中，被移出寄存器的最后一位会进入CF。
        

---

### **`jnz` (Jump if Not Zero) - 如果不为零则跳转**

- **完整名称：** Jump if Not Zero / 如果不为零则跳转
    
- **等价指令：** `jne` (Jump if Not Equal / 如果不相等则跳转)。`jnz` 和 `jne` 是完全相同的指令，会被编译成同一个机器码。
    
- **检查的标志位：** **ZF (Zero Flag / 零标志位)**
    
- **跳转条件：** 当 `ZF = 0` 时，执行跳转。（注意：`ZF=1` 表示结果为零，`ZF=0` 表示结果不为零）
    

**`jnz` 主要用于以下场景：**

1. **检查两个数是否不相等（与`cmp`配合）：**
    
    - `cmp` 指令会计算两个操作数的差，并根据结果设置标志位。如果两个数相等，差为零，`ZF`会被置为1。
        
        代码段
        
        ```
        cmp eax, ebx   ; 比较eax和ebx
        jne values_are_not_equal ; 如果eax不等于ebx (差不为零, ZF=0), 则跳转
        ```
        
2. **检查运算结果是否不为零：**
    
    - 任何影响ZF标志位的算术或逻辑运算之后，都可以用`jnz`来判断结果。
        
        代码段
        
        ```
        sub eax, eax   ; eax = eax - eax = 0。ZF会被置为1
        jnz label      ; ZF=1, 所以不会跳转
        ```
        
3. **实现循环（最常见的用途之一）：**
    
    - 通过一个计数器递减，只要计数器还不为零，就继续循环。
        
        代码段
        
        ```
        mov ecx, 10    ; 设置循环次数为10
        loop_start:
          ; ... 循环体内的代码 ...
          dec ecx      ; ecx减1。当ecx从1减到0时, ZF会置为1
          jnz loop_start ; 只要ecx还不为0(ZF=0), 就跳回loop_start
        ; ecx为0后, 循环结束, 执行这里的代码
        ```
        

---

### **总结对比**

|特性|`jc` (Jump on Carry)|`jnz` (Jump if Not Zero)|
|---|---|---|
|**中文含义**|如果**进位/借位**则跳转|如果结果**不为零**则跳转|
|**检查的标志位**|**CF (进位标志位)**|**ZF (零标志位)**|
|**跳转条件**|`CF = 1`|`ZF = 0`|
|**等价指令**|无|`jne` (如果不相等则跳转)|
|**核心应用场景**|检查**无符号数**运算、位操作、**BIOS/系统调用失败**|检查两个数是否**不相等**、运算结果是否**非零**、**循环控制**|
|**典型前置指令**|`add`, `sub`, `shl`, `stc`, `int`|`cmp`, `test`, `dec`, `inc`, `sub`, `and`|

一句话总结：

jc 关心的是运算过程“有没有溢出或出错”，而 jnz 关心的是运算结果“是不是零”。它们是为解决完全不同的逻辑问题而设计的。




>
> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=199&annotation=7997R|操作系统真象还原 (郑纲), p.199]]
> 我们利用它实现段式内存管理。如果该描述符中 的  P  位为  1，表示该段在内存中存在。访问过该段后，CPU  将段描述符中的  A  位置  1，表示近来刚访问过该段。 相反，如果  P  位为  0，说明内存中并不存在该段，这时候  CPU  将会抛出个  NP（段不存在）异常，转而去执行中 断描述符表中  NP  异常对应的中断处理程序，此中断处理程序是操作系统负责提供的，该程序的工作是将相应的 段从外存（比如硬盘）中载入到内存，并将段描述符的  P  位置  1，中断处理函数结束后返回，CPU  重复执行这个 检查，继续查看该段描述符的  P  位，此时已经为  1  了，在检查通过后，将段描述符的  A  位置  1。
段描述符的 A 位由 CPU 置 1，但清 0 工作可是由操作系统来完成的。此位干吗用的呢？如果仅仅用来表示该段被访问过，这也意义不大啊。其实这正是软件和硬件相互配合的体现，操作系统每发现该位为 1 后就将该位清 0，这样一来，在一个周期内统计该位为 1 的次数就知道该段的使用频率了，从而可以找出使用频率最低的段。当物理内存不足时，可以将使用频率最低的段换出到硬盘，以腾出内存空间给新的进程。当段被换出到硬盘后， 操作系统将该段描述符的 P 位置 0。当下次这个进程上 CPU 运行后，如果访问了这个段，这样程序流就回到了刚开始 CPU 检查出 P 位为 0、紧接着抛出异常、执行操作系统中断处理程序、换入内存段的循环




|标志位（缩写）|全称|意义说明|取值/作用说明|
|---|---|---|---|
|**P**|Present|存在位，页是否在物理内存中|1：在内存；0：不在，访问会pagefault异常|
|**RW**|Read/Write|读写位，页是否可写|1：可读可写；0：只读|
|**US**|User/Supervisor|用户/特权级位，决定哪类特权可访问|1：用户/所有级别可访问；0：仅超级用户/高特权可访问|
|**PWT**|Page-level Write-Through|页级写透位，是否使用写透缓存|1：写透方式；0：回写方式|
|**PCD**|Page-level Cache Disable|页级高速缓存禁止位|1：禁止该页缓存在缓存中；0：允许缓存|
|**A**|Accessed|访问位，页是否被CPU访问过|1：被访问过，CPU自动置位|
|**D**|Dirty|脏页位，页内容是否被写过|1：被写过，CPU自动置位|
|**PAT**|Page Attribute Table|页属性表位，扩展页属性|复杂用法，通常为0|
|**G**|Global|全局页位，是否为全局页（不因TLB刷新而失效）|1：全局页，刷新CR3时TLB不清除此页|
|**AVL**|Available for Software|软件保留位，操作系统可自定义使用|—|

---

### **简要说明：**

- **P/RW/US** 是最常用、最核心的权限/存在相关标志。
- **PWT/PCD/PAT** 是缓存相关的优化与扩展功能。
- **A/D** 用于追踪访问与写入状态（由CPU硬件自动更新）。
- **G** 影响页表项在TLB中的驻留策略。
- **AVL** 是“软定义”，通常操作系统自用。

#### cr0寄存器


|  位号 | 缩写     | 名称                  | 置 1 的含义                                         | 置 0 的含义               | 常见备注                         |
| --: | ------ | ------------------- | ----------------------------------------------- | --------------------- | ---------------------------- |
|   0 | **PE** | Protection Enable   | 进入**保护模式**（需先准备好GDT等）                           | 实模式                   | 打开分页前通常先置 PE=1               |
|   1 | **MP** | Monitor Coprocessor | 在 **TS=1** 时，`WAIT/FWAIT` 会触发 **#NM**（配合懒切换FPU） | `WAIT/FWAIT` 不受 TS 影响 | 与 **TS** 配合监控协处理器使用          |
|   2 | **EM** | Emulation           | **无 x87**，所有 x87 指令触发 **#NM**（软件仿真）             | 存在 x87/FPU            | 现代机一般 EM=0                   |
|   3 | **TS** | Task Switched       | 置位后首个 x87/SSE 指令触发 **#NM**（用于**懒保存/恢复**浮点上下文）   | 不触发                   | OS 在任务切换时置 1，使用后清 0          |
|   4 | **ET** | Extension Type      | 历史位；在 486+ 上恒为 **1**                            | —                     | 只为兼容保留                       |
|   5 | **NE** | Numeric Error       | x87 异常通过 **#MF(16)** 上报（内部方式）                   | 旧式 FERR#/IRQ13 方式     | 现代 OS 必置 **1**               |
|  16 | **WP** | Write Protect       | **内核态也不得写**只读页（更强保护）                            | 内核态可写只读页              | 现代 OS 常置 **1**               |
|  18 | **AM** | Alignment Mask      | **用户态**且 `EFLAGS.AC=1` 时，对未对齐访问触发 **#AC**       | 不做对齐检查                | 调试/健壮性检查                     |
|  29 | **NW** | Not Write-through   | 与 **CD** 联合控制缓存写策略；通常为 **0**                    | —                     | 现代系统多设 NW=0；关闭缓存时常与 CD 一起置 1 |
|  30 | **CD** | Cache Disable       | **禁用缓存**（需配合 `WBINVD`/`INVD` 刷新）                | 允许缓存                  | 临时关缓存做内存测试/设备访问              |
|  31 | **PG** | Paging              | **启用分页**（结合 CR3/CR4 设置）                         | 线性地址=物理地址（无分页）        | 开启长模式/PAE 等也需要 PG=1          |

**注意事项**

- 未列出的位为**保留位**，应按手册要求写 0。
- 打开分页的典型顺序：准备页表→写 CR3→（已 PE=1）置 PG=1；若使用 PAE/长模式，还需先配好 **CR4**、**EFER**。
- 关闭/开启缓存（CD/NW）前后应按手册要求**刷新缓存**并注意 MTRR/PAT 的影响。

bochs 支持很多 `info` 子命令，主要用于**查看系统当前的硬件/虚拟内存/寄存器/断点等状态**。

### 常用 info 命令有：

- `info tab`  
    查看当前的**虚拟地址到物理地址的页表映射**（paging translation）。
- `info reg`  
    查看 CPU 寄存器内容（eax、ebx、cr0、cr3等）。
- `info break`  
    查看断点信息。
- `info cpu`  
    查看CPU状态（模式、标志等）。
- `info seg`  
    查看段寄存器详细信息





### Kernel



下面把你贴的几页内容按“是什么—怎么看—用来干嘛”的思路梳理成一张速记单。

# 1）ELF 是什么

* **ELF（Executable and Linkable Format）**：Unix/Linux 常用的目标文件格式，既面向**链接**（linking），也面向**装载/运行**（execution）。
* 常见三种文件类型（`e_type`）

  * **ET\_REL（可重定位文件）**：编译后未链接的 `.o`；给链接器用。
  * **ET\_EXEC（可执行文件）**：最终可执行；给加载器/内核用。
  * **ET\_DYN（共享目标/动态库）**：`*.so`；既可被装载为共享库，也可作为位置无关可执行由动态加载器启动。
    （还有 ET\_CORE 等）

# 2）两种“视图”：段 vs. 节

* **执行视图（Segments）**：运行时真正被映射/装载的单位，描述在内存中的布局。

  * 由 **Program Header Table**（程序头表）描述。
* **链接视图（Sections）**：链接时操作的单位（`.text`、`.data`、`.bss`、`.rodata`、`.symtab`、`.strtab`、`.rel*` 等）。

  * 由 **Section Header Table**（节头表）描述。
* 关系：多个 **section** 会被归并/映射到少数几个 **segment** 中（例如把 `.text`、只读常量等合并进可装载的代码段）。

# 3）ELF 文件总结构（自上而下）

1. **ELF Header（文件头，`Elf32_Ehdr`）**——总目录
2. **Program Header Table（程序头表）**——执行用目录（可选/对 ET\_REL 可为空）
3. **各个 Section 的数据**——真正内容
4. **Section Header Table（节头表）**——链接用目录（可选/对某些最小可执行也可无）

# 4）ELF Header 关键字段（选 32 位为例）

* `e_ident[16]`：魔数与元信息

  * `0..3`：`0x7F 'E' 'L' 'F'` 魔数
  * `EI_CLASS`（`e_ident[4]`）：32/64 位
  * `EI_DATA`（`e_ident[5]`）：大小端（LSB/MSB）
  * 还包含版本、ABI、ABI 版本等
* `e_type`：文件类型（ET\_REL/ET\_EXEC/ET\_DYN/ET\_CORE/…）
* `e_machine`：体系结构（如 `EM_386` 表示 i386）
* `e_entry`：入口虚拟地址（可执行/动态库重要）
* `e_phoff` / `e_shoff`：程序头表/节头表在文件内的偏移
* `e_flags`：体系结构相关标志
* `e_ehsize`：ELF 头大小
* `e_phentsize`、`e_phnum`：程序头表项大小/数量
* `e_shentsize`、`e_shnum`：节头表项大小/数量
* `e_shstrndx`：节名字符串表所在的节下标

> 小技巧：`file a.out` 会直接显示 “ELF 32-bit LSB …”，等价于读取 `e_ident` 的关键信息。

# 5）Program Header（`Elf32_Phdr`）——装载器看什么

每个表项描述一个段或与装载相关的信息：

* `p_type`：段类型

  * 常见：

    * **PT\_LOAD**（可装载段）
    * **PT\_DYNAMIC**（动态链接信息）
    * **PT\_INTERP**（动态链接器路径）
    * **PT\_NOTE**（注记）
    * **PT\_PHDR**（程序头本身所在映射）
    * 以及保留/平台相关 `PT_LOPROC..PT_HIPROC`
* `p_offset`：该段在**文件**内的起始偏移
* `p_vaddr`：该段在**内存**中的虚拟地址
* `p_paddr`：物理地址（多数用户态系统忽略）
* `p_filesz`：文件中该段大小
* `p_memsz`：装载到内存后的大小（可大于 `p_filesz`，如 `.bss`）
* `p_flags`：访问权限标志 **PF\_X/PF\_W/PF\_R**
* `p_align`：对齐约束

> 加载器依据程序头表把 `PT_LOAD` 段从 `p_offset` 处拷贝/映射到 `p_vaddr`，再按 `p_flags` 设权限，然后跳到 `e_entry` 执行。

# 6）Section（简述）——链接器看什么

* 常见节：`.text`（代码）、`.rodata`（只读常量）、`.data`（已初始化数据）、`.bss`（未初始化数据，文件中不占空间）、`.symtab/.strtab`（符号/字符串表）、`.rel[a].*`（重定位）。
* **Section Header Table** 给出每个节的类型、大小、对齐、文件/内存位置等；链接器据此完成合并、重定位、符号解析。

# 7）把概念对上实践命令

* `file a.out`：快速识别是 32/64 位、大小端、是否动态/静态、是否 stripped。
* 生成可执行再转裸二进制（示例）：

  ```bash
  gcc -m32 -ffreestanding -fno-pie -c main.c -o main.o   # 产出 ET_REL
  ld  -m elf_i386 -Ttext 0x1500 -e main -o kernel.elf main.o  # 产出 ET_EXEC，含 ELF/Program Header
  objcopy -O binary kernel.elf kernel.bin  # 仅保留可装载内容 => 纯二进制
  ```

  * `kernel.elf` 用来调试（有头/符号/表）
  * `kernel.bin` 只有段内容，没有 ELF/表头，给引导程序直接装载

---

**一句话记忆**：
ELF 有“链接视图（sections/节头表）”和“执行视图（segments/程序头表）”；文件最前面是 ELF 头，告诉你两张“目录表”在哪。链接阶段看节，装载阶段看段。



`nm` = **显示目标文件/可执行文件中的符号表**，能帮你确认函数和变量的位置、类型，以及有没有未解析的引用。


### `wc -l`
**nm kernel.bin | wc -l**

- `wc` = word count（字/行统计）
    
- `-l` 选项表示统计 **行数**。




#### loader 根据解析出来的信息，把缓冲区里的代码段、数据段等，分别拷贝到它们最终的目标内存地址

---


1.  **目标内存地址是虚拟地址吗？**
    * 链接时指定的地址 (`0xc0015000`) 是**虚拟地址**。
    * 但是，`loader` 在执行“拷贝”动作时，是把内核代码从一个**物理地址**（缓冲区 `0x70000`）拷贝到另一个**物理地址**（比如 `0x100000`）。

2.  **这个拷贝是什么意思？**
    * 它是一个纯粹的**内存数据复制** (`memcpy`)。就像在你的电脑上把一个文件从 C 盘的一个文件夹复制到另一个文件夹一样。`loader` 把内核的代码和数据，从内存中的临时“下载”位置，搬到最终的“安装”位置。

3.  **把目标虚拟地址映射到物理地址吗？**
    * **是的，但这发生在“拷贝”完成之后，跳转到内核之前。** “拷贝”本身只是搬运数据。搬运完成后，`loader` 最重要的工作之一就是设置页表，来建立这个**映射关系**。这是两个独立的步骤。

---

### 详细的执行流程分解

让我们把 `loader` 的工作流程放慢，看看每一步到底发生了什么。假设我们的内核很简单，只有一个代码段。

**背景**: `loader` 已经运行，并且把 `kernel.bin` 完整地加载到了**物理地址** `0x70000` 的缓冲区中。

1.  **【准备工作】 loader 进入保护模式**
    `loader` 首先会把自己从 16 位的实模式切换到 32 位的保护模式。这是后续所有操作的前提。

2.  **【解析】 loader 读取 ELF 头**
    `loader` 读取位于 `0x70000` 的 `kernel.bin` 的 ELF 程序头。它找到了一个 `PT_LOAD` 类型的段，并从程序头中读到了以下关键信息：
    * **虚拟地址 (`p_vaddr`)**: `0xc0015000`
    * **文件内偏移 (`p_offset`)**: 比如 1000 (表示代码段从文件的第 1000 个字节开始)
    * **大小 (`p_filesz`)**: 比如 8192 字节 (8KB)

3.  **【拷贝】 loader 搬运内核代码**
    `loader` 现在需要为这 8KB 的代码找一个最终的物理存放位置。一个最简单、最常见的选择就是**1MB 以上的第一个可用物理内存地址**。我们就假设 `loader` 决定把它放在物理地址 **`0x100000`** (也就是 1MB 的位置)。

    于是，`loader` 执行了一个内存拷贝操作：
    * **源地址**: `0x70000` (缓冲区基址) + `1000` (代码段在文件内的偏移) = **`0x71000`** (物理地址)
    * **目标地址**: **`0x100000`** (物理地址)
    * **拷贝长度**: 8192 字节

    执行完后，内核的代码段就静静地躺在**物理地址 `0x100000` 到 `0x101FFF`** 这片区域了。

    **关键点**：此时，代码虽然在物理地址 `0x100000`，但它内部所有的跳转、函数调用、地址引用都是基于 `0xc0015000` 编译的。如果你现在直接 `JMP 0x100000`，程序会立刻崩溃。

4.  **【映射】 loader 建立页表**
    这是最神奇的一步。为了让 CPU 能够正确执行位于 `0x100000` 的代码，`loader` 必须建立一个“地址翻译词典”（即页表）。

    `loader` 会在内存中创建页目录和页表，然后写入一条关键的映射规则：
    **“将虚拟地址 `0xc0015000` 映射到物理地址 `0x100000`”**

5.  **【激活与跳转】 loader 开启分页并移交控制权**
    * `loader` 将页目录的物理地址加载到 `CR3` 寄存器。
    * `loader` 设置 `CR0` 寄存器中的分页标志位，**正式开启分页机制**。从这一刻起，CPU 看到的所有地址都会被当作虚拟地址进行翻译。
    * 最后，`loader` 执行 `JMP 0xc0015000`。

    CPU 收到这个跳转指令后，MMU（内存管理单元）会介入：它查找页表，发现 `0xc0015000` 这个虚拟地址对应的是 `0x100000` 这个物理地址。于是，CPU 的指令指针就指向了**物理地址 `0x100000`**，内核的第一条指令被成功取出并执行。

### 生动的比喻

* **物理地址 `0x100000`**: 你新家的实际门牌号，“幸福路 123 号”。
* **虚拟地址 `0xc0015000`**: 你给新家起的名字，“我的理想乡”。
* **拷贝**: 搬家公司（`loader`）把你的家具从临时仓库（缓冲区 `0x70000`）搬到了新家“幸福路 123 号”。
* **映射 (页表)**: 你去邮局（设置 MMU）登记：“所有寄往‘我的理想乡’的信件，请全部送到‘幸福路 123 号’”。
* **跳转**: 你告诉朋友：“来‘我的理想乡’找我玩！” 朋友（CPU）根据邮局的登记信息，准确地找到了你的新家“幸福路 123 号”。

![[ELF程序头.png]]![[ELF文件头.png]]**readelf -l 的作用**

-l 表示 显示 Program Headers（也叫 segment headers）。

这个选项会把 ELF 文件的 程序头表 (Program Header Table, PHT) 打印出来，告诉你：

每个段 (Segment) 的类型 (Type，如 LOAD, DYNAMIC, INTERP 等)

段在文件中的偏移 (Offset)

映射到内存时的虚拟地址 (VirtAddr) 和物理地址 (PhysAddr)

文件中占用大小 (FileSiz) 和内存中占用大小 (MemSiz)

段的访问权限 (Flg → R/W/X)

对齐方式 (Align)



![[函数调用栈.png]]![[程序布局.png]]好的，这段文字描述的是 x86 保护模式下一个**极其重要且核心的安全机制**：**特权级切换时的栈切换**。

为了让您彻底明白，我将用一个比喻和分步解释来说明。

### 简单的比喻：去银行办事

想象一下这个场景：

- **你 (普通市民)** = **低特权级 (Ring 3) 的应用程序**。
    
- **你的钱包和记事本** = **应用程序的栈 (SS:ESP)**。这里面是你的私有数据。
    
- **银行金库 (安全区域)** = **高特权级 (Ring 0) 的内核**。
    
- **金库里专用的、干净的工作台** = **内核专用的栈 (由TSS提供)**。
    
- **银行柜员** = **CPU**。
    

你去银行办理一个需要进入金库才能处理的业务（比如提取大量现金）。

1. **你发起请求**：你（应用程序）通过一个特定的服务窗口（**系统调用**）向柜员（CPU）提出请求。
    
2. **柜员做交接准备 (进入高特权级)**：
    
    - 柜员**不能**把你的钱包和记事本（应用程序的栈）带进金库（内核），因为那是不安全的，可能会弄乱金库。
        
    - 于是，柜员在一个**专用的交接单**上，记下**你的名字**和你**钱包里有多少钱**（保存你应用程序的`SS`和`ESP`）。
        
    - 他把这张交接单放在**金库里那个干净的工作台**（内核栈）的**最上面**。
        
3. **柜员在金库工作**：柜员现在完全使用金库里的工作台（切换到内核栈）来处理你的业务。
    
4. **业务完成，交还给你 (返回低特权级)**：
    
    - 柜员处理完业务后，看到了放在工作台最上面的那张交接单。
        
    - 他根据交接单上的记录，准确地找到了你，并把你的钱包和记事本原封不动地还给你（通过`iret`指令恢复应用程序的`SS`和`ESP`）。你就可以继续做你自己的事了。
        

---

### 对文字的技术解释

现在我们用技术的语言来解释您截图中的那段话。

#### 第一段核心意思：为什么要切换栈，以及如何切换？

> “当处理器由低向高特权级转移时，它自动地把当时低特权级的栈地址 (SS 和 ESP) 压入了转移后的高特权级所在的栈中...”

- **为什么？**
    
    - **安全**：应用程序的栈 (Ring 3) 是不可信的。如果内核 (Ring 0) 也使用这个栈，应用程序可以通过一个恶意的栈指针让内核崩溃，或者窃取信息。
        
    - **可靠**：应用程序的栈可能很小，而内核执行复杂操作时可能需要更大的栈空间。
        
- **如何切换？(Ring 3 -> Ring 0)**
    
    1. 当应用程序通过**中断**或**调用门**请求内核服务时，CPU检测到特权级要提升。
        
    2. CPU会暂停应用程序，并自动去一个叫做 **TSS (Task State Segment)** 的特殊结构里查找**内核专用栈的地址**（即`SS0`和`ESP0`）。
        
    3. CPU将应用程序当前的栈指针 `SS` 和 `ESP` **压到**这个新的内核栈上。同时也会压入返回地址 `CS:EIP` 等信息。
        
    4. 最后，CPU将自己的 `SS` 和 `ESP` 寄存器更新为TSS里记录的内核栈地址。
        

> “所以，当用返回指令如 retf 或 iret 从高特权级向低特权级返回时，处理器可以从当前使用的高特权级的栈中获取低特权级的段选择子及偏移量。”

- **如何返回？(Ring 0 -> Ring 3)**
    
    - 内核代码执行完毕后，会调用 `iret` 指令。
        
    - 这个指令会触发一个逆向操作：CPU从当前内核栈的顶部，**弹出**之前保存的应用程序的 `SS`, `ESP`, `CS`, `EIP` 等，并把它们恢复到寄存器中。
        
    - 这一瞬间，CPU就从Ring 0安全地返回到了Ring 3，应用程序从它被中断的地方继续无缝执行。
        

#### 第二段核心意思：TSS中的栈指针是固定的，不会被更新

> “TSS 中栈指针值都是固定的，每次进入高特权级都会重复使用它们... 处理器也不会自动把该高特权级栈指针更新到 TSS 中”

这是另一个关键点，对应我们比喻里的“**金库里的工作台每天都会被清扫干净**”。

- `ESP0` 在TSS里存的**不是一个动态变化的指针**，而是一个**固定的栈顶地址**。
    
- 假设TSS里`ESP0`的值是`0x8000`。
    
    - 第一次系统调用发生时，`ESP`被设置为`0x8000`。内核在执行中可能会用掉一些栈空间，返回时`ESP`可能变成了`0x7F00`。
        
    - 当内核通过`iret`返回后，这个`0x7F00`的值**就被丢弃了**。
        
    - **下一次**再有系统调用发生时，CPU**仍然会从TSS中读取`0x8000`**，并将`ESP`再次设置为`0x8000`。
        
- **为什么这么设计？**
    
    - 这是一种**隔离机制**。它确保了每次系统调用都像是一次全新的、干净的进入。上一次系统调用如果把内核栈弄得一团糟（比如有内存泄漏），也不会影响到下一次系统调用，因为栈指针总是被重置到那个初始的、干净的位置。
        

> “如果想保留上一次高特权级的栈指针，咱们得自己手动更新 TSS 中相应栈的数据。”

- 这指的是在一些非常高级和特殊的设计（比如某些多任务内核）中，如果你确实需要保存内核栈的状态，那么操作系统内核需要自己写代码，手动去修改TSS里的值。CPU硬件**不会自动帮你做**这件事。

### TSS 即 Task State Segment
它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段
> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=243&annotation=8085R|当处理器进入不同的特权级时，它自 动在  TSS  中找同特权级的栈，你懂的，TSS  是处理器硬件原生的系统级数据结构，处理器当然知道  TSS 中哪些字段是目标栈的选择子及偏移量]]
是由 TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS 就成了

![[tss结构.png]]

**作用**
- 当程序需要从低权限的用户态 (Ring 3) 进入高权限的内核态 (Ring 0) 时（例如，发生系统调用或中断），CPU必须立即切换到一个安全、隔离的内核堆栈上，以防止用户程序破坏内核。

	这个专用的内核堆栈的地址（具体为 SS0 和 ESP0/RSP0）就预先存储在TSS中。CPU硬件会自动、强制性地从TSS里读取这个地址，并切换过去。可以说，TSS为CPU指明了通往内核安全工作区的路。

- 设定I/O端口的访问权限

	TSS内部可以包含一个“I/O许可位图”。操作系统可以通过修改这个位图，来精确授权某个用户态任务可以直接访问哪些硬件I/O端口。
	这个功能在虚拟化（如允许虚拟机直接访问某些硬件）和一些特殊的驱动程序中非常有用






### 门描述符
描述符同段描述符类似，都是 8 字节大小的数据结构，用来描述门中通向的代码。


> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=249&annotation=8140R|操作系统真象还原 (郑纲), p.249]]
> > 假设某调用门描述符位于 GDT 中第 1 个位置，这样的指令“call 0x0008：0x1234”，在调用此调用门时，偏移量 0x1234 会被 CPU 忽略
> 
> 
- **CPU执行指令**： CPU遇到指令 `call 0x0008:0x1234`。它看到这是一个远调用（far call）。
    
- **查找描述符**： CPU会拿着选择子（Selector）`0x0008` 去GDT（全局描述符表）中查找对应的描述符。
    
- **识别描述符类型**： 当CPU读取GDT中`0x0008`位置的描述符时，它会检查这个描述符的类型。此时它发现，这**不是一个普通的“代码段描述符”**，而是一个**“调用门描述符”（Call Gate Descriptor）**。
    
- **读取“门”内的信息**： 这个“调用门描述符”本身就是一个“路标”，它内部已经包含了**完整且固定**的目标地址信息：
    
    - 一个**目标代码段选择子**（指向真正要执行的代码所在的代码段，例如内核代码段）。
        
    - 一个**目标偏移地址**（指向该代码段内的某个特定入口点，例如内核函数的起始地址）。
        
- **执行跳转并忽略原偏移量**：
    
    - 因为CPU发现它要通过一个“门”进行跳转，它就会**完全采纳“门描述符”里记录的目标地址**。
        
    - 它会**丢弃** `call` 指令中提供的偏移量 `0x1234`。
        
    - 然后，CPU将“门”里指定的“目标代码段选择子”加载到 `CS` 寄存器，将“目标偏移地址”加载到 `EIP` 寄存器，完成跳转。


![[调用门描述符.png]]



> [!PDF|note] [[操作系统真象还原 (郑纲).pdf#page=251&selection=223,2,243,4&color=note|操作系统真象还原 (郑纲), p.251]]
> 其高 32 位的起始处有个“参数个数”，这是处理器将用户提供的参数复制给内核时需要用到的，参数在栈中的顺序是挨着的，所以处理器只需要知道复制几个参数就行了，这就是调用门描述符中“参数个数”的作用，它是专门给处理器准备的。该位是用 5 个 BIT 来表示的，所以最多可传递 31 个参数。

**call 指令调用“调用门”的完整过程**

**切换堆栈**：CPU识别出特权级变化，立刻根据TSS找到并加载新的内核堆栈。
- 触发切换： 您的用户程序（CPL=3）通过`int 0x80`或`syscall`指令发起系统调用。
- 确定目标： CPU发现这是一个要将特权级提升到 **Ring 0** 的操作。
- 查找TSS： CPU硬件通过 `TR` 寄存器找到当前TSS的位置。
- 读取新栈地址： 因为目标是 **Ring 0**，CPU会自动从TSS中读取 `SS0` 和 `ESP0` 的值。此时，CPU就拿到了“**新栈段选择子**”（来自SS0）和“新栈顶指针”（来自ESP0）。
- 执行安全检查（您上一个问题）： CPU拿到从`SS0`读出的**新栈段选择子**后，立刻去GDT中查找对应的描述符，并严格检查其 **DPL** 是否为0，以及 **TYPE** 是否为可写数据段。
- 切换栈： 如果检查通过，CPU将 `SS0` 的值加载到 `SS` 寄存器，将 `ESP0` 的值加载到 `ESP` 寄存器。就在这一瞬间，栈完成了从用户栈到内核栈的切换。

**保存现场**：为了能顺利返回，CPU在新的内核堆栈上，依次压入所有返回需要的信息，包括：
 - 旧的用户堆栈位置 (SS_old, ESP_old) 
 - 用户程序传递的参数（从用户栈复制而来）
 - 程序的返回地址 (CS_old, EIP_old)

		**跳转执行**：CPU加载调用门中指定的内核代码地址，正式开始在 Ring 0 执行内核服务。
**安全返回**：内核服务完成后，一条 retf 指令会触发逆向过程，CPU利用之前保存在内核堆栈上的信息，恢复所有现场，安全地返回到用户程序中断的地方继续执行。

![[特权级转移栈变化过程.png]]


**用 retf 指令从调用门返回的过程**
**第一步：判断返回类型**
CPU 执行 retf 时，首先会查看当前栈上保存的返回地址，特别是 CS（代码段选择子）。
它会读取这个 CS 选择子中的 RPL (请求者特权级)。这个 RPL 值代表了程序即将返回到的特权级。
CPU 将这个 RPL 与当前的 CPL (当前特权级) 进行比较。

**第二步：根据类型，执行两种不同的操作**
情况A：平级返回 ( RPL == CPL )
判定：这是一个在相同特权级内部的普通返回。
操作：CPU 只需从栈中弹出 EIP 和 CS，然后跳转到返回地址继续执行。过程非常简单。

情况B：跨级返回 ( RPL > CPL )
判定：这是一个从高特权级（如内核）向低特权级（如用户程序）的复杂返回。
操作：CPU 会执行一套更复杂、更安全的流程：
恢复堆栈：除了弹出 EIP 和 CS，还必须从栈中额外弹出 ESP 和 SS，以切换回原来低特权级的堆栈。
安全检查：检查 DS、ES 等数据段寄存器，防止它们在返回低特权级后，仍然指向高权限的内存数据，从而避免安全漏洞。

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=254&annotation=8154R|操作系统真象还原 (郑纲), p.254]]
> 如果在返回时需要改变特权级，**将会检查数据段寄存器 DS、ES、FS 和 GS 的内容**，如果在它们之中，某个寄存器中选择子所指向的数据段描述符的 DPL 权限比返回后的 CPL（CS.RPL）高，即数值上返回后的 CPL>数据段描述符的 DPL，处理器将把数值 0 填充到相应的段寄存器。


### RPL

> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=256&annotation=8157R|操作系统真象还原 (郑纲), p.256]]
> GDT、LDT 等全局系统数据表都是由操作系统构建的，只有操作系统知道表中段描述符、门描述符的索引，理所当然选择子也应该由操作系统构建，由操作系统分派给用户进程使用就行了。所以，一般情况下选择子都是由操作系统提供的，也就是说控制权在操作系统手里。**当用户程序请求操作系统服务，如果需要提交选择子作为参数，为安全起见，操作系统会把选择子中的 RPL 改为用户程序的 CPL**，为此，处理器还提供了修改 rpl 的相关指令


> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=256&annotation=8160R|操作系统真象还原 (郑纲), p.256]]
> 整个 4GB 内存是一个段，操作系统为所有用户进程构建了两个用户级的 RPL 为 3 的选择子，分别指向 4GB 的用户数据段和 4GB 的用户代码段。因为用户程序在自己的虚拟地址空间中运行，各用户进程的虚拟地址不冲突，所以各用户程序共用这两个选择子就够了，也就是说**用户进程在申请系统服务时无需提供选择子，从而，操作系统在系统服务程序内部就用这两个用户级的选择子便可以搞定一切。**

用户程序的 CPL 是由操作系统在加载用户程序时赋予的，记录在段寄存器 CS 中的低 2 位，就是 RPL 的位置，当它申请了系统服务，如果提交了选择子作为参数，选择子中的 RPL 也会被操作系统修改为用户进程的 CPL
***处理器的特权检查，都是只发生在往段寄存器中加载选择子访问描述符的那一瞬间***

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=259&annotation=8168R|操作系统真象还原 (郑纲), p.259]]
> 在该内核服务程序中，**操作系统将这个用户所提交的选择子的 RPL 变更为用户进程的 CPL**，也就是指向缓冲区所在段的选择子的 RPL 变成了 3。
-
**CPL 不在单独的寄存器里，始终等于当前 `CS` 段选择子的低 2 位。**
- 当从用户态（ring3）通过门进到内核（ring0）时，CPU 会做**特权级切换并把“旧现场”压到新栈（内核栈）**。  这个**被压到栈上的“旧 CS”**（以及旧 RIP、旧 SS、旧 RSP 等）里，**低 2 位就是调用者当时的 CPL=3**。  所以内核若想“知道调用者的 CPL”，读**内核栈上保存的旧 CS**就行：`caller_cpl = saved_cs & 0x3`。


#### 特权检查例子
##### 场景

- 进程在 **CPL=3**（用户态），想读到一项系统信息（在**内核数据段，DPL=0**）。
    
- OS 提供一个**调用门**（call gate），门的 **DPL=3**，目标是某内核服务例程所在的**非一致代码段**（DPL=0）。
    

##### 进入内核（通过调用门）

1. **门可达性检查**：要求 `max(CPL,RPL) ≤ 门.DPL`。  
    用户用的门选择子 RPL=3，CPL=3 → 允许使用该门。
    
2. **目标代码段检查**：门指向的段必须“可执行 + P=1”。（目标段 DPL=0）
    
3. **跨级动作**（因为从 3→0）：
    
    - **新 CPL = 目标段 DPL = 0**。
        
    - 硬件从 **TSS** 取 ring0 栈 → **切栈**。
        
    - 按门里的 **ParameterCount** 把旧栈上的 N 个参数**复制**到新栈。
        
    - 把**旧 SS:ESP、旧 CS:EIP**等压到新栈，以便 `lret` 返回。
        

##### 在内核中处理用户缓冲区指针

4. 用户把“**段选择子:偏移**”（指向用户缓冲区）当参数传上来。此选择子的 **RPL 是不可信的**（可能被伪造为 0）。
    
5. **内核先把这个选择子的 RPL 强制设为调用者的 CPL=3**（常用 `ARPL` 或直接把低两位置 11b）。  
    目的：让后续访问按**用户级**审查，防止“借内核之手”访问内核段。
    
6. 内核用该选择子把数据写回缓冲区时，数据段访问遵循：  
    **`DPL ≥ max(CPL, RPL)`**
    
    - 此时 `CPL=0`、`RPL=3` ⇒ 要求目标段 **DPL≥3**。
        
    - 若用户恶意把选择子指向 **内核段（DPL=0）**，检查失败，写入被硬件拒绝并触发异常；
        
    - 若确实指向 **用户段（DPL=3）**，检查通过，写入成功。
        
7. 若内核服务例程需要访问**内核自己的数据/代码**，则使用**RPL=0 的内核选择子**来访问（因为这些段 **DPL=0**）。
    

##### 返回用户态

8. 服务例程结束，用 **`lret`**（或对应快速路径 `sysret`）按新栈上保存的现场**降权返回**到用户态（`CPL=3`），继续执行。

##### jmp指令
- **近跳转（near jmp）**：只改 `EIP/RIP`，不换段、不换 CPL，当然也**不保存现场**（不压栈）。
    
- **远跳转（far jmp）到代码段描述符**：同时改 `CS:EIP`，做一次**特权检查**，但仍然**不保存返回地址**。
    
    - 目标是**非一致段（C=0）**：必须同级；规则等价于 **CPL = 目标段 DPL** 且 **RPL ≤ CPL**，因此 **不能借 jmp 改变 CPL**。
        
    - 目标是**一致段（C=1）**：允许进入但 **CPL 不变**（条件大致是 **CPL ≥ DPL**），同样**不能提权/降权**。
        
- **通过“门”**：
    
    - **JMP 不能用调用门（call gate）**，所以不能靠 jmp 受控“升权”。
        
    - **JMP 可以跳到任务门/TSS** → 触发**任务切换**；这时硬件会把当前任务现场保存到 TSS，再加载新任务的现场（这属于“换任务”，和“函数返回”概念不同）。
        
- **对比 CALL**：`CALL`（尤其 far call）会把返回地址（近 call 压 `IP`，远 call 压 `CS:IP`）压到栈上，日后 `RET/LRET` 能返回；而 `JMP` 没有这个步骤，因此**不可用 RET 返回**。
    

**JMP 的远转移能跨段，但不会像 CALL 那样保存返回点，也不能借此改变 CPL；只有 CALL 经过调用门或 `INT/SYSCALL` 这类“门”才能受控跨级。**


### IO 特权级
> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=260&annotation=8171R|操作系统真象还原 (郑纲), p.260]]
> IO  读写特权是由标志寄存器  eflags  中的  IOPL  位和  TSS  中的  IO  位 图决定的
![[eflags 寄存器.png]]
数值上CPL≤IOPL，程序既可以执行IO特权指令，又可以操作所有的IO端口。倘若数值上CPL > IOPL， 程序也不是完全无法进行任何 IO 操作,数值上 CPL > IOPL，则可以通过 IO 位图来设置部分端口的访问权限

I/O 位图只是在数值上 CPL > IOPL，即当前特权级比 IOPL 低时才有效，若当前特权级大于等于 IOPL，任何端口都可直接访问不受限制。**TSS 中I/O 位图可以存在，也可以不存在**,所以 TSS 的段界限 TSS limit，即实际大小-1， 并不固定。当 TSS 中不包括 I/O 位图时，TSS 只有 104 字节大小。

- ![[tss.png]]TSS 里有个 **“I/O 位图偏移”** 字段（相对 TSS 基址的偏移）。  
- 只有当这个偏移 **位于 [104, TSS limit]** 范围内时，才认为 **存在 IOPB**；否则视为**没有 IOPB**（TSS 最小长度 104 字节）。

- IOPB 的**最大长度**是 **8192 字节（=65536 位，对应全部 16 位端口空间）**，**后面必须再跟 1 个字节 `0xFF` 作为“哨兵/防越界字节”**。  

 - IOPB 的 TSS 实际大小是：**I/O 位图偏移 + 8192 + 1**（按需要也可更短，但末尾同样要有那 1 字节 `0xFF`）。
##### 为什么末尾一定要有 `0xFF`
1. **跨字节/越界检查的保险**  
    端口是**按字节编址**的。比如 `in ax, 0x234` 实际会访问 **0x234 和 0x235 两个字节端口**，CPU 必须检查这两个端口在位图里的两个 bit 都为 0 才放行。  
    如果某次访问跨过了你的位图末尾，CPU 会读到那 **最后的哨兵字节 `0xFF`** → 视为**禁止**，从而**不会**读到位图之外（TSS 之外）的内存。
    
2. **统一地“禁止超出位图覆盖的端口”**  
    你不想覆盖全部 65536 个端口时，位图之外的端口都会因为这个 `0xFF` 被**自动拒绝**，逻辑更简单、更安全。






## 完善内核

##### **栈帧基址**
`ESP` 是**栈顶指针**，每次 `push/pop` 都会变，**不稳定**；
'`EBP` 在函数内部保持不变，**稳定**，所以称它指向“栈帧基址/帧基址”。
“**栈帧基址**”就是：**被调用函数在进入时把 `EBP` 固定在本次调用这块栈区域的一个基准位置（通常是保存的旧 EBP 处），随后用 `[EBP+偏移]` 访问参数/返回地址，用 `[EBP-偏移]` 访问局部变量**
![[Pasted image 20250917214908.png]]
##### cdecl 调用约定
（1）调用者将所有参数从右向左入栈。 
（2）调用者清理参数所占的栈空间。


```
主调函数
1  push 2           ; 参数 b 入栈
2  push 3           ; 参数 a 入栈
3  call subtract    ; 调用函数 subtract
4  add esp, 8       ; 回收参数占用的栈空间 (cdecl 由调用者清理栈)

被调函数
1  push ebp           ; 保存调用者的 ebp
2  mov ebp, esp       ; 建立新栈帧，ebp = esp
3  mov eax,[ebp+0x8]  ; eax = 第1个参数 a
4  add eax,[ebp+0xc]  ; eax += 第2个参数 b
5  mov esp, ebp       ; 恢复 esp
6  pop ebp            ; 恢复调用者的 ebp
7  ret                ; 返回，并弹出返回地址
```

<font size='6' color="#e36c09">为什么汇编语言编写的函数可以通过c语言调用？</font>


```
put_char('K');
```
这句C语言代码会被编译器编译为：

```
push 'K'           ; 1. 参数压栈（从右向左）
call put_char      ; 2. 调用函数
add esp, 4         ; 3. 调用者清理栈（cdecl 约定）
```



> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=270&annotation=8177R|操作系统真象还原 (郑纲), p.270]]
> 调用“系统调用”有两种方式。 
> （1）将系统调用指令封装为 c 库函数，通过库函数进行系统调用，操作简单。 
> （2）不依赖任何库函数，直接通过汇编指令 int 与操作系统通信。

> [!PDF|8, 109, 221] [[操作系统真象还原 (郑纲).pdf#page=273&annotation=8180R|操作系统真象还原 (郑纲), p.273]]
> 在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字 extern。 y 在 C 代码中只要将符号定义为全局便可以被外部引用（一般情况下无需用额外关键字修饰，具体请参考 C 语言手册），引用外部符号时用 extern 声明即可


### 实现自己的打印函数
#### 显存
![[Pasted image 20250918220736.png]]![[Pasted image 20250918220755.png]]
**I/OAS (Input/Output Address Select) 的作用**
- 当 I/OAS = 0：
	CRT Controller Registers → 端口 3B4h/3B5h
	Input Status #1 → 3BAh
	Feature Control 写端口 → 3BAh
- 当 I/OAS = 1：
	CRT Controller Registers → 端口 3D4h/3D5h
	Input Status #1 → 3DAh
	Feature Control 写端口 → 3DAh
**默认情况下，Miscellaneous Output Register 的值为 0x67，即 I/OAS = 1，使用 彩色/graphics**

> [!PDF|187, 97, 229] [[操作系统真象还原 (郑纲).pdf#page=284&annotation=8183R|操作系统真象还原 (郑纲), p.284]]
> 用户进程是需要用  iretd  返回指令上  CPU  运行的，这些以后会说的， 大家暂且接受这个结论。CPU  在执行  iretd  指令时会做特权检查，它检查  DS、ES、FS、GS“数据”段寄存器的 内容，这里的数据我加了引号，它只是修饰段寄存器的定语，用来指除代码段寄存器  CS  和栈段寄存器  SS  之外 的段寄存器。在  32  位保护模式下它们中存储的都是选择子，要是有任何一个段寄存器所指向的段描述符的  DPL 权限高于从  iretd  命令返回后的  CPL（这个返回后的  CPL  也就是新的  CPL，CPL  就是加载到  CS  寄存器中选择子 的  RPL），CPU  就会将该段寄存器赋值为  0。
**用户进程的特权级由 CS 寄存器中选择子的 RPL 字段决定，它将成为进程在 CPU 上运行时的 CPL**

-----------------


<font  size='5' color="#e36c09">ERROR</font>

![[Pasted image 20250928224858.png]]`

使用dd命令时，没有加上 `conv = notrunc` 参数，对**普通文件**（比如 `hd60M.img` 这样的镜像），dd 默认会以**截断**方式打开（相当于 `O_TRUNC`）。  这会把文件长度先清零，再开始写，会让镜像文件变小。

<font  size='5' color="#e36c09">如何处理？</font>
使用提供的**bximage**重新创建一个磁盘镜像，创建过程遇到权限不足问题，使用以下命令修改权限

```
sudo chown -R "$USER":"$USER" /home/opt
- chown：change owner，修改所有者/组。
    
-R：递归，对目标目录及其所有子目录、文件都生效。
    
- "$USER":"$USER`：把所有者设为当前用户，把所属组也设为当前用户同名的组
  
  
写 MBR 到 0 号扇区
dd if=mbr.bin    of=hd40.img bs=512 count=1 conv=notrunc
# 写 loader 到 2 号扇区（第 1 扇区留空）
dd if=loader.bin of=hd40.img bs=512 count=1 seek=2 conv=notrunc

```




#### 实现字符串打印

> [!PDF|important] [[操作系统真象还原 (郑纲).pdf#page=288&selection=255,3,267,4&color=important|操作系统真象还原 (郑纲), p.288]]
>  32 位保护模式下的栈，要么压入 16 位操作数，要么压入 32 位操作数
当 CPU 在 32 位模式下执行指令时：

1. **没有 `0x66` 前缀（默认情况）**：指令按 32 位操作。
    
    - `PUSH EAX` -> 压入 4 字节，`ESP` 减 4。
        
    - `MOV EAX, EBX` -> 32 位寄存器之间传送数据。
        
2. **有 `0x66` 前缀（重载情况）**：CPU 会将**紧跟其后**的这一条指令按 16 位操作。
    
    - 汇编 `PUSH AX` 编译后的机器码实际上是 `0x66` 加上 `PUSH AX` 的指令码。CPU 看到 `0x66`，就知道这次压栈操作是 16 位的。
        
    - 执行 `PUSH AX` -> 压入 2 字节，`ESP` 减 2。
        
    - 执行 `MOV AX, BX` -> 16 位寄存器之间传送数据

![[Pasted image 20251009232523.png]]



### 内联汇编
 AT&T 风格的汇编![[Pasted image 20251010001029.png]]

#### 扩展内联汇编

**格式：asm [volatile] (“assembly code”:output : input : clobber/modify)**

**output:output** 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。output 中每个操作数的格式为：
**<center>“操作数修饰符约束名”（C 变量名） </center>**
其中的引号和圆括号不能少，操作数修饰符通常为等号'='。多个操作数之间用逗号'，'分隔。

**input：input** 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。input 中每个操作数的格式为：
**<center>“[操作数修饰符] 约束名”（C 变量名） </center>**
其中的引号和圆括号不能少，操作数修饰符为可选项。多个操作数之间用逗号'，'分隔。

l**obber/modify**：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来，


**寄存器约束**：解释了如何在使用 GCC（GNU 编译器集合）时，将不同的寄存器与变量在输入/输出约束中进行映射。

- **a**：表示寄存器 `eax/ax/al`
    
- **b**：表示寄存器 `ebx/bx/bl`
    
- **c**：表示寄存器 `ecx/cx/cl`
    
- **d**：表示寄存器 `edx/dx/dl`
    
- **D**：表示寄存器 `edi/di`
    
- **S**：表示寄存器 `esi/si`
    
- **q**：表示 4 个常用寄存器：`eax/ebx/ecx/edx`
    
- **r**：表示 6 个常用寄存器：`eax/ebx/ecx/edx/esi/edi`
    
- **g**：表示可以将数据保存到内存中（寄存器和内存）。
    
- **A**：将 `eax` 和 `edx` 组合成一个 64 位整数。
    
- **f**：表示浮点寄存器。
    
- **u**：表示 2 个浮点寄存器

**内存约束”**  ：是告诉 **GCC 编译器**：  
在内联汇编中，`input` 和 `output` 的操作数应直接使用 **C 语言变量的内存地址**，而不是通过寄存器中转。  
这样汇编代码就能**直接从内存读取或写入**这些变量。

换句话说：  
汇编代码操作的其实是 **C 变量的指针（地址）**，而不是寄存器中的拷贝。

---

##### ⚙️ 常见内存约束符号

- `m`：操作数可以使用**任意一种内存形式**。  
    编译器可以自由选择具体的寻址方式。
    
- `o`：操作数是内存变量，但**必须通过偏移量访问**，  
    即形如 `offset_address` 的地址访问方式（如 `[base + offset]`）。
    

---
##### ***序号占位符***
是对在 output 和 input 中的操作数，按照它们从左到右出现的次序从 0 开始编号，一直到 9，也就是说最多支持 10 个序号占位符。操作数用在 assembly code 中，引用它的格式是%0～9。
![[Pasted image 20251010014640.png]]**由于扩展内联汇编中的占位符要有前缀%，为了区别占位符和寄存器，只好在寄存器前用两个%做前缀啦**

> [!PDF|important] [[操作系统真象还原 (郑纲).pdf#page=302&selection=99,4,116,3&color=important|操作系统真象还原 (郑纲), p.302]]
> **名称占位序**需要在 output 和 input 中把操作数显式地起个名字，它用这样的格式来标识操作数： [名称]”约束名”（C 变量）
![[Pasted image 20251010015533.png]]

##### **约束中还有操作数类型修饰符**

###### **output**
=：表示操作数是只写，相当于为 output 括号中的 C 变量赋值，如=a(c_var)，此修饰符相当于 c_var=eax。
+：表示操作数是可读写的，告诉 gcc 所约束的寄存器或内存先被读入，再被写入。 
&：表示此 output 中的操作数要独占所约束（分配）的寄存器，只供 output 使用，任何 input 中所分配的寄存器不能与此相同。注意，当表达式中有多个修饰符时，&要与约束名挨着，不能分隔。
###### **input** ****
 %：该操作数可以和下一个输入操作数互换。

**场景**


```c
int x, y;
/* 目的必须在 eax；源任意。没有可交换修饰符 % */
asm("addl %1, %0" : "=a"(x) : "r"(y));
```

假设**在进入这段 asm 之前**，寄存器分配的现状刚好是：

* `y` 已经在 **`eax`**（别的代码先放进去的）
* `x` 在 **`ecx`**

但你的模板固定为 `addl %1, %0`（源→目的），而约束又要求 `%0` 在 `eax`。
于是编译器必须把**当前在 `eax` 里的 `y` 先挪走**，再把 `x` 搬进 `eax`，才能执行 `add`：

```asm
mov   %eax, %edx   ; ① 先把 y 从 eax 挪到临时寄存器，防止被覆盖
mov   %ecx, %eax   ; ② 把 x 搬到 eax（因为 %0 必须是 eax）
addl  %edx, %eax   ; ③ 做真正的加法
```

这里就多出了**两条 `mov`**（有时根据分配情况可能只多一条，但核心就是“要搬家”）。

##### 加上 `%` 会怎样？

把输入写成 **`"%r"(y)`**（带 `%`），表示“**这个输入和它后面的那个输入可交换**”。于是编译器可以**对调两者的角色**，等价地生成另一个绑定：让“已经在 `eax` 的 y”当“目的”，让 `x` 当“源”。这样直接就能算：

```asm
addl  %ecx, %eax   ; 直接 y += x，不需要前面的搬运
```

**没有任何额外的 `mov`。**

---
###### **clobber/modify（告诉 gcc 我们动了哪些资源，例寄存器和内存）**
内联汇编代码修改了标志寄存器 eflags 中的标志位，需要在 clobber/modify 中用”**cc”** 声明

如果我们在 output 中使用了内存约束，gcc 自然会得到哪块内存被修改。但如果被修改的内容并未在 output 中，我们就需要用**”memory”**告诉 gcc ，比如使用movsd指令修改了内存

用”memory”声明的原因就是**清除寄存器缓存**，gcc为了提速，会把内存中的数据缓存到寄存器中，在程序运行过程中某个内存的值可能会出现变化，此时寄存器中的数据还是旧数据，用memory声明可以解决这个问题


## 七、中断
### 7.3 中断分类

#### 7.3.1 外部中断
外部中断是指来自 CPU 外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断。 CPU 提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都共享公共线路连接到 CPU。外部硬件的中断是通过两根信号线通知 CPU 的，这两根信号线就是 INTR（INTeRrupt）和 NMI（Non Maskable Interrupt）。
![[Pasted image 20251010154227.png]]
##### 可屏蔽中断
> [!PDF|important] [[操作系统真象还原 (郑纲).pdf#page=312&selection=174,0,194,16&color=important|操作系统真象还原 (郑纲), p.312]]
> 可屏蔽中断是通过 INTR 引脚进入 CPU 的，外部设备如硬盘、网卡等发出的中断都是可屏蔽中断。可屏蔽的意思是此外部设备发出的中断，CPU 可以不理会，因为它不会让系统宕机，所以可以通过 eflags 寄存器的 IF 位将所有这些外部设备的中断屏蔽。
这类可屏蔽中断，CPU 可以选择不用理会，甚至，即使在理会后，也可以像 Linux 那样，**把中断分为上半部和下半部分开处理。**

把中断处理程序中需要立即执行的部分划分到上半部，这部分是要限时执行的，而中断处理程序中那些不紧急的部分则被推迟到下半部中去完成。由于中断处理程序的上半部是刻不容缓要执行的，所以上半部是在关中断不被打扰的情况下执行的。当上半部执行完成后就把中断打开了，下半部也属于中断处理程序，下半部则是在开中断的情况下执行的，如果有新的中断发生，原来这个旧中断的下半部就会被换下 CPU，先执行新的中断处理程序的上半部。


##### 不可屏蔽中断
不可屏蔽中断是通过 NMI 引脚进入 CPU 的，它表示系统中发生了致命的错误，不可屏蔽中断的中断向量号为 2。不可屏蔽中断引起的致命错误原因有很多，每一种都是硬伤，出现了基本上可以认为用软件解决不了，可屏蔽中断并不会导致致命问题，它的数量是有限的，所以每一种中断源都可以获得一个中断向量号

#### 7.3.2 内部中断

##### 软中断，
就是由软件主动发起的中断，因为它来自于软件，所以称之为软中断。由于该中断是软件运行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误
**IF 位置（Interrupt Flag Position）**：  
在 `EFLAGS` 寄存器中，**IF** 位位于某一特定位置，用于指示 CPU 是否启用中断。如果 **IF 位为 1**，CPU 将响应外部中断；如果 **IF 位为 0**，CPU 将禁止中断。这样，当某些程序需要阻止中断（例如，在某些关键代码执行期间）时，会将该位清除（设置为 0）

| 指令        | 触发的中断向量号 | 描述                  | 备注                                 |
| --------- | -------- | ------------------- | ---------------------------------- |
| **int 8** | 8        | 8 位立即数中断，用于系统调用     | 8 位立即数可表示 256 种中断，匹配处理器所支持的中断数     |
| **int3**  | 3        | 调试断点指令，用于调试程序       | 父进程将子进程的指令替换为 `int3`，触发 3 号中断执行调试器 |
| **into**  | 4        | 中断溢出指令，触发 4 号中断     | 只有当 `eflags` 寄存器中的 `OF` 位为 1 时才会触发 |
| **bound** | 5        | 检查数组索引越界指令，触发 5 号中断 | 用于检查数组下标是否超出范围                     |
| **ud2**   | 6        | 未定义指令，触发 6 号中断      | 用于软件测试，主动触发不可识别的指令，通常没有实际用途        |
除第一种的“int 8 位立即数”之外，其他的几种又可以称为异常。因为它们既具备软中断的“主动”行为，又具备***异常***的“错误”结果。

##### 异常
由于是运行时错误，所以它不受标志寄存器 eflags 中的 IF 位影响，只要中断关系到“正常”运行，就不受 IF 位影响。

|类型（中文）|英文|描述|是否可恢复|CPU 返回时指令位置|典型例子|
|---|--:|---|:-:|---|---|
|Fault（故障 / 可修复异常）|Fault|发生后可由中断处理程序修复，处理完毕通常可以重试出错的指令。处理前 CPU 会把状态恢复到异常发生前的状态，再调用中断处理程序。|可恢复（可修复）|返回后仍指向**导致 fault 的那条指令**，可重试|page fault（页面缺失）|
|Trap（陷阱 / 调试型异常）|Trap|通常用于调试或单步执行（例如 `int3`），触发后用于让调试器介入，处理完后继续向下执行。|可恢复 / 用于观察|返回后指向**导致异常指令的下一条指令**（继续执行）|`int3`（断点）、单步陷阱|
|Abort（终止型异常）|Abort|最严重的异常，通常不可修复且无法继续运行。操作系统为自保会终止该进程。|不可恢复（致命）|无法继续执行该进程（通常进程被杀掉）|硬件故障、严重的系统错误|
异常和不可屏蔽中断的中断向量号是由 CPU 自动提供的，而来自外部设备的可屏蔽中断号是由中断代理提供的（咱们这里的中断代理是 8259A），软中断是由软件提供的

| 来源            |          谁提供向量号 | 示例向量/备注                                 |
| ------------- | --------------: | --------------------------------------- |
| CPU 异常（同步）    |          CPU 自动 | 除零 0；调试陷阱 1；页错 14 等                     |
| 不可屏蔽中断 NMI    |    CPU（/系统硬件线路） | NMI → 向量 2（不可屏蔽）                        |
| 外部硬件 IRQ（可屏蔽） |  中断控制器（如 8259A） | PIC 映射后通常为 32–47（IRQ0→32）               |
| 软中断（软件触发）     | 软件通过 `int n` 指定 | `int 0x80`（Linux i386 系统调用）、`int 3`（断点） |



### 中断描述符表

中断描述符表（Interrupt Descriptor Table，IDT）是***保护模式***下用于存储中断处理程序入口的表，当 CPU 接收一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，*然后执行中断处理程序*。实模式下用于存储中断处理程序入口的表叫**中断向量表（Interrupt Vector Table，IVT）**

| 名称  |             英文 | 描述                                                                          | 进入时是否把 `EFLAGS.IF` 清零 | 可放置的位置          | 描述符 type（二进制） | 备注                                 |
| --- | -------------: | --------------------------------------------------------------------------- | :-------------------: | --------------- | ------------: | ---------------------------------- |
| 任务门 |      Task Gate | 与 TSS 配合的硬件任务切换入口，描述里记录的是 TSS 选择子（偏移未用）。用于硬件级的任务切换（现代多数 OS 很少用）。            |      不适用（与 IF 无关）     | GDT / LDT / IDT |        `0101` | 通过 TSS 实现任务切换，描述符里指向 TSS。          |
| 中断门 | Interrupt Gate | 标准的中断/异常入口。CPU 进入时**会自动把 `EFLAGS.IF` 置 0**（屏蔽可屏蔽中断），以避免中断嵌套。最后通过 `iret` 返回。 |         会清零 IF        | 仅 IDT           |        `1110` | 常用于硬件中断或需要屏蔽后续中断的情况。               |
| 陷阱门 |      Trap Gate | 与中断门类似的入口，但 CPU 进入后**不会自动清 IF**，便于调试或希望继续接受中断的场景。                           |      **不会**清零 IF      | 仅 IDT           |        `1111` | 常用于断点/单步等调试相关场景。                   |
| 调用门 |      Call Gate | 用于从低特权级调用高特权级例程（跨特权级调用），描述中记录例程地址。不能用 `int` 指令触发，只能通过 `call`/`jmp`。         |      不适用（由调用语义决定）     | GDT / LDT       |        `1100` | 可设置 DPL，典型用于允许用户态（DPL=3）调用受控的内核入口。 |
![[Pasted image 20251010165634.png]]
##### 中断描述符表寄存器  IDTR

![[Pasted image 20251010170926.png]]

16 位的表界限，表示最大范围是 0xffff，即 64KB。可容纳的描述符个数是 64KB/8=8K=8192 个。第 0 个门描述符也是可用的，中断向量号为 0 的中断是除法错。但处理器只支持 256 个中断，即 0～254，中断描述符中其余的描述符不可用。在门描述符中有个 P 位，所以，咱们将来在构建 IDT 时，记得把 P 位置 0，这样就表示门描述符中的中断处理程序不在内存中。

**加载 GDTR** 
lidt 48 位内存数据
在这 48 位内存数据中，前 16 位是 IDT 表界限，后 32 位是 IDT 线性基地址。


####  7.4.1 中断处理过程及保护

**定位中断描述符（IDT 查询）**

用中断向量号作为索引：描述符地址 = IDTR.base + (vector × 8)（x86 32 位保护模式下每个 IDT 条目 8 字节）。

CPU 从 IDT 读取对应的门描述符（interrupt/trap/call/task gate 等）。

**特权检查（Privilege checks）**

软件中断（由 int n、int3、into 等指令发起）：CPU 先做「门的门槛检查（gate.DPL）」——检查当前特权级 CPL 是否被允许调用该门（门的 DPL）。只有通过门的 DPL 检查后，才继续下一步。

所有情况（或外部/CPU 异常）都会做的检查：CPU 根据门描述符的 selector 去取对应的目标代码段描述符（在 GDT 或 LDT），读出目标代码段的 DPL（即目标段的特权级要求），然后比较 CPL 与目标段 DPL，以决定是否允许转移以及是否需要做特权级提升（栈切换等）。

外部设备中断 / CPU 异常：因为不是软件主动调用的门（即不是执行 int 的程序调用），CPU 跳过门的 DPL 检查，只做与目标段 DPL 相关的检查（即直接判断能否进入目标段）。

若任何检查不通过，CPU 抛出相应异常（拒绝转移）。

**执行中断处理（进入处理程序）**

特权检查通过后，CPU 会保存现场（把 EFLAGS、CS、EIP 等压栈；有些异常还会压入一个 error code，压入顺序/位置由体系结构定义），若发生从低特权向高特权的转移还会进行 栈切换（使用 TSS/内核栈）。

把门描述符中记录的目标段选择子加载到 CS，把偏移加载到 EIP，开始执行中断/异常处理程序。

处理完后通过 iret（或等价返回路径）恢复现场并返回到原来的特权级与指令位置。

![[Pasted image 20251010192509.png]]
> [!PDF|important] [[操作系统真象还原 (郑纲).pdf#page=319&selection=174,0,204,4&color=important|操作系统真象还原 (郑纲), p.319]]
> 中断发生后，**eflags 中的 NT 位和 TF 位会被置 0。如果中断对应的门描述符是中断门，标志寄存器 eflags 中的 IF 位被自动置 0，避免中断嵌套**，即中断处理过程中又来了个新的中断，这是为防止在处理某个中断的过程中又来了个相同的中断，即同一种中断未处理完时又来了一个，这会导致一般保护性（GP）异常。

**中断返回的指令是 iret**，它从栈中弹出数据到寄存器 cs、eip、eflags 等，根据特权级是否改变，判断是否要恢复旧栈，也就是说是否将栈中位于 SS_old 和 ESP_old 位置的值弹出到寄存 ss 和 esp。当中断处理程序执行完成返回后，通过 iret 指令从栈中恢复 eflags 的内容。

**处理器提供了专门用于控制 IF 位的指令**，通过它，IF 可以直接控制。指令 cli 使 IF 位为 0，这称为关中断，指令 sti 使 IF 位为 1，这称为开中断，**IF 位只能限制外部设备的中断**

**NT 位和 TF** 
TF 表示 Trap Flag，也就是陷阱标志位，这用在调试环境中，当 TF 为 0 时表示禁止单步执行，也就是说，进入中断后将 TF 置为 0，表示不允许中断处理程序单步执行。

NT 位表示 Nest Task Flag，即任务嵌套标志位，也就是用来标记任务嵌套调用的情况。任务嵌套调用是指 CPU 将当前正执行的旧任务挂起，转去执行另外的新任务，待新任务执行完后，CPU 再回到旧任务继续执行。

####  7.4.2 中断发生时的压栈
![[Pasted image 20251010200613.png]]![[Pasted image 20251010200636.png]]**ss和cs都是16位寄存器，需要补0**

<font  size=5 color="#e36c09">ss和sp的作用</font>

| 寄存器            | 全称            |                       位宽 | 主要作用                                                                                                                                     |
| -------------- | ------------- | -----------------------: | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **SS**         | Stack Segment | 16 位（实模式为段基；保护/长模式为段选择子） | 指定**栈所处的段**。实模式下 SS×16 是段基址；保护模式下 SS 保存**段选择子**（由它到 GDT/LDT 找到“栈段描述符”的 base、limit、DPL 等属性）。64 位长模式里大多忽略段基（除 FS/GS），但 SS 仍用于**特权级切栈**等控制。 |
| **SP/ESP/RSP** | Stack Pointer |               16/32/64 位 | 指定**当前栈顶偏移**。`push` 前先减指针再写入；`pop` 先读再加指针。按位宽分别用于 16/32/64 位模式。                                                                          |
**`iret`**（interrupt return）用于**从中断/异常处理程序返回**。它按固定顺序从栈里弹寄存器，恢复现场并回到被打断的指令继续执行（或回到原特权级与原栈）。

<font  size=5 color="#c00000">iret`返回时栈的期望布局（32 位）</font>

> 栈顶必须按下面的顺序摆好，否则 `iret` 只会“对号入座”把错误数据弹给寄存器。

- **必需**：`EIP_old` → `CS_old` → `EFLAGS_old`
    
- **若发生过特权切换（如 Ring3→Ring0）**：还要在上面三项**之后**再有  
    `ESP_old` → `SS_old`
    
- **某些异常带有 `ERROR_CODE`**：处理程序需要**先把 error code 弹走/跳过**（例如 `add esp, 4`），保证 `EIP_old` 处在栈顶，再执行 `iret`。
    

> `iret` 的弹栈顺序：  
> 依次弹出 **EIP → CS → EFLAGS**（若需要，再弹 **ESP → SS**），然后根据恢复的 `EFLAGS`（如 IF、TF 等）以及段寄存器状态继续执行。

##### iret返回流程

**取出 CS_old、EIP_old 做权限检查**

用 CS_old 的 RPL 与目标代码段描述符的 DPL 比较，并结合当前 CPL，判断是否要改变特权级（CPL←RPL）。
同时对 CS_old 的选择子/描述符做有效性检查（存在位、类型、界限等）。

**装载 EIP ← EIP_old、CS ← CS_old**

若不需要改变特权级，则后续仍在当前栈上继续恢复；
若需要改变特权级，则后面还要进行栈切换。

**弹出并恢复 EFLAGS**
对特权相关位（如 IOPL/IF）做权限检查与屏蔽（取决于返回后的 CPL）。

**仅当需要改变特权级时：恢复栈段与栈指针**
继续从栈中取出 SS_old 与 ESP_old，加载为新的 SS/ESP，完成从内核栈回到用户栈（或其它级别的栈）的切换。
注意 32 位下 SS_old 是 16 位选择子，但作为栈操作数按 32 位条目处理（高 16 位零扩展）。

**数据段寄存器的安全处理**
如果返回后某个 DS/ES/FS/GS 指向的段 在新 CPL 下不可用（例如该段的 DPL 更“高”——数值更小），处理器会把该寄存器清空为 Null 选择子，防止越权；之后需要软件在新特权级下重新加载可用的数据段。
![[Pasted image 20251010204623.png]]



#### 中断错误码
![[Pasted image 20251010204013.png]]

|字段|位/范围|含义|取值说明|备注|
|---|---|---|---|---|
|**EXT**|bit0|External event 标志：指明中断源是否来自处理器外部|1＝来自外部（非 NMI 的可屏蔽外部中断/设备等）；0＝来自处理器内部|NMI 不算作外部中断，这里为 0|
|**IDT**|bit1|选择子是否指向 **IDT**|1＝选择子指向 IDT 中的中断描述符；0＝不指向 IDT|当该位为 0 时，**TI** 才有意义|
|**TI**|bit2|Table Indicator：所引用的选择子来自 **GDT** 还是 **LDT**|0＝从 **GDT** 检索；1＝从 **LDT** 检索|仅在 **IDT=0** 时有效|
|**Index（选择子索引）**|bits 3–15|选择子的索引号（在表中的下标）|用于在 GDT/LDT/IDT 中定位目标描述符|与段选择子的 13 位索引对应|
|**保留**|bits 16–31|保留|固定为 0|——|
**全 0 的错误码**出现时，表示中断的发生与特定的段无关，或者引用了一个空描述符，引用描述符就是往段寄存器中加载选择子的时候，处理器发现选择子指向的描述符是空的。

通常能够压入错误码的中断属于中断向量号在 0～32 之内的异常，而外部中断（中断向量号在 32～ 255 之间）和 int 软中断并不会产生错误码。


### 7.5 可编程中断控制器 8259A

![[Pasted image 20251010210916.png]]![[Pasted image 20251010212449.png]]、

<font size=5 color="#ff0000">中断处理流程</font>：

1. **外设发出中断请求（IRQn）**
    
    - 主板连线把该请求送到 8259A 的某个 **IRQ 引脚**。
        
    - 8259A 先用 **IMR（中断屏蔽寄存器）** 判断：若该位为 1 → 被屏蔽，忽略；为 0 → 放行。
        
2. **请求被锁存到 IRR**
    
    - 通过 **IRR（请求寄存器）** 记录“哪个 IRQ 线上有请求”。
        
    - **优先级判决器**在所有 _未屏蔽_ 的 IRR 位中选出**优先级最高**的那个待处理请求。
        
3. **向 CPU 申请中断**
    
    - 8259A 将 **INT** 线置位，向 CPU 发“中断请求”。
        
    - CPU 响应该请求后，会发出 **第一拍 INTA**（中断响应信号）。
        
4. **第一拍 INTA：锁定本次中断**
    
    - 8259A 在这一步**最终确定**要服务的 IRQ（把“刚才选出来的那个”锁定）。
        
    - 将对应位从 **IRR 清除**，并把该位在 **ISR（正在服务寄存器）** **置 1**，表示“此优先级正在服务”。
        
    - 处于 ISR 的优先级会**阻塞同级/更低级**的后续请求（它们仍可在 IRR 排队），而**更高优先级**的请求仍可被接受（取决于 CPU 是否允许嵌套）。
        
5. **第二拍 INTA：给出中断向量号**
    
    - 8259A 在数据总线上送出 **向量号（0–255）**（8086/88 模式为 8 位类型号，配合 IVT 查入口）。
        
    - CPU 取到向量后压栈（FLAGS、CS、IP/EIP），转入相应 **ISR（中断服务程序）**。
        
6. **服务期间的并发请求处理**
    
    - 若又有新的 IRQ：其位会进入 **IRR**。
        
    - **低于或等于当前在 ISR 中的优先级**：只排队，不会被送进 CPU。
        
    - **高于当前优先级**：在 CPU 允许（IF=1、允许嵌套）时，8259A 仍可拉起 INT，请求嵌套服务。
        
7. **结束中断（EOI）**
    
    - 普通模式：**CPU 在 ISR 末尾向 8259A 发送 EOI 命令**（OCW2，非特定/特定均可），8259A 将对应 **ISR 位清 0**。
        
    - **自动 EOI 模式**：8259A 会在**第二拍 INTA 之后**自动把本次中断的 **ISR 位清 0**，无需软件发 EOI。
        
8. **调度下一次中断**
    
    - 一旦相关 **ISR 位清 0**，优先级判决器会查看 **IRR** 中是否仍有待处理请求；若有，重新进入步骤 3~5 的流程。
        
    - 若在服务过程中收到 **第二个 INTA**（对应另一次请求），8259A 会按已锁定的那个请求继续流程。
        

---


- **IMR**：屏蔽位（1=屏蔽），决定“能否进 IRR 参与仲裁”。
    
- **IRR**：待处理队列（已到达、未被 CPU 接受）。
    
- **ISR**：正在服务集合（阻塞同级/更低级，再次仲裁时只允许更高级抢占）。
    






![[machine learning/操作系统/shot/image 2.png|700x1680]]
#### 7.5.2 8259A 的编程

**8259A 内部有两组寄存器**

**ICW** 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式
**OCW** 来操作控制 8259A

***ICW1***

| 位     | 名称       | 含义                               | x86/PC 取值建议     | 备注                    |
| ----- | -------- | -------------------------------- | --------------- | --------------------- |
| D0    | **IC4**  | 是否还要写 **ICW4**                   | **1**（必须写 ICW4） | 文中说明：x86 系统 IC4 必须为 1 |
| D1    | **SNGL** | 连接方式：单片 or 级联                    | 单片=1；级联=0       | 级联时后续需要 **ICW3**      |
| D2    | **ADI**  | 8085 调用间隔（Call Address Interval） | **x86 不用**      | 8086/88 无此需求          |
| D3    | **LTIM** | 触发方式：电平/边沿                       | 0=边沿触发；1=电平触发   | PC 通常用**边沿**          |
| D4    | —        | **固定为 1**（ICW1 标志位）              | 1               | 说明这是 ICW1             |
| D5–D7 | —        | 8085 相关                          | **x86 不用**      | 可忽略                   |
|       |          |                                  |                 |                       |
![[image.png]]
> 写入端口：主片 0x20、从片 0xA0（先写 ICW1 再写 ICW2…）。

----

***ICW2***

| 字段    | 含义          | 在 8086/88 的用法                         | 例子（常见 PC 布局）                                  |
| ----- | ----------- | ------------------------------------- | --------------------------------------------- |
| D7–D3 | 向量高 5 位（基址） | 组成中断类型号的高 5 位                         | 主片基址常设 **0x20**（32），从片 **0x28**（40）           |
| D2–D0 | 由 IRQ# 决定   | CPU 最终向量号 = **(ICW2 & 0xF8) \| IRQ#** | IRQ0→0x20，IRQ7→0x27；从片 IRQ8→0x28 … IRQ15→0x2F |
![[image-1.png]]

----

***ICW3***

| 角色     | 写入内容                            | 含义          |
| ------ | ------------------------------- | ----------- |
| **主片** | 哪些 IR 口上**挂了从片**（每一位对应 IR0–IR7） | 用位图指出级联链路   |
| **从片** | 自己接到主片的**哪一路 IR**（0–7 的编号）      | 告诉控制器它的级联入口 |
**主片的 ICW3（位图）**

- 格式：`S7 S6 S5 S4 S3 S2 S1 S0`（对应 IR7…IR0）
    
- **含义**：哪条 **IR 引脚上挂了从片**
    
    - 该位 **1** = 这条 IR线上连接了一个从片
        
    - 该位 **0** = 连接外设/空
        
- 示例：若主片在 **IR2** 和 **IR5** 上各接了一个从片
    
    - 主片 ICW3 = `0010 0100b` = **0x24**
        
![[image-2.png]]
**从片的 ICW3（编号）**

- 格式：`0 0 0 0 0 ID2 ID1 ID0`（**高 5 位清 0**）
    
- **含义**：本从片连接到**主片的哪一路 IR**（0–7）
    
    - 只用 **ID2..ID0** 三位表示编号
        
- 示例：
    
    - 从片 **A** 接在主片 **IR2** → `0000 0010b` = **0x02**
        
    - 从片 **B** 接在主片 **IR5** → `0000 0101b` = **0x05**
![[image-3.png]]
**中断响应时**：主片把“被服务的 IRQ 号”在级联线上广播；各从片把这个号码与自己 **ICW3 的 ID2..ID0** 比较，**匹配的那片**知道“在叫我”，于是继续参与向量传递；不匹配的忽略。

---


***ICW4***

| 位（Bit） | 名称                                  | 含义                            |       x86 下典型取值 | 说明 / 注意                                                                       |
| -----: | ----------------------------------- | ----------------------------- | --------------: | ----------------------------------------------------------------------------- |
|    7–5 | —（保留）                               | 未定义 / 保留位                     |               0 | 必须置 0                                                                         |
|      4 | **SFNM**（Special Fully Nested Mode） | 特殊全嵌套模式位                      |           0（通常） | 0/1 切换全嵌套模式与“特殊全嵌套”模式（影响级联时的嵌套判定策略）。文档中：SFNM=0 表示全嵌套，SFNM=1 表示特殊全嵌套。          |
|      3 | **BUF**（Buffered mode）              | 是否工作在缓冲/缓冲化模式                 |     0（PC 常用非缓冲） | 0 = 非缓冲；1 = 缓冲。仅缓冲模式下，M/S 位才有意义（用于主/从判定）。                                     |
|      2 | **M/S**（Master/Slave）               | 指定本片为主片还是从片                   | —（仅在 BUF=1 有意义） | 1 = 主片（Master），0 = 从片（Slave）。若 BUF=0（非缓冲），此位无效。用于多片缓冲级联时指示角色。                 |
|      1 | **AEOI**（Auto EOI）                  | 自动结束中断（Auto End Of Interrupt） |           0（典型） | 1 = 自动 EOI（8259A 在适当时刻自动清 ISR）；0 = 非自动，需软件/CPU 在 ISR 结束时显式发送 EOI（OCW2）来清 ISR。 |
|      0 | **µPM / uPM**（microProcessor mode）  | 微处理器兼容模式选择                    |       1（x86 必填） | 0 = 兼容 8080/8085；1 = 8086/88 / x86 模式。x86 系统应置 1。                             |
![[image-4.png]]

---


##### **OCW1**

![[image-5.png]]

|位 (bit)|名称|对应 IRQ 线|含义|取值说明|
|--:|---|---|---|---|
|bit0|M0|IRQ0|屏蔽 IRQ0 的中断信号|`1` = 屏蔽 (禁止)；`0` = 允许（通过）|
|bit1|M1|IRQ1|屏蔽 IRQ1|`1` = 屏蔽；`0` = 允许|
|bit2|M2|IRQ2|屏蔽 IRQ2|`1` = 屏蔽；`0` = 允许|
|bit3|M3|IRQ3|屏蔽 IRQ3|`1` = 屏蔽；`0` = 允许|
|bit4|M4|IRQ4|屏蔽 IRQ4|`1` = 屏蔽；`0` = 允许|
|bit5|M5|IRQ5|屏蔽 IRQ5|`1` = 屏蔽；`0` = 允许|
|bit6|M6|IRQ6|屏蔽 IRQ6|`1` = 屏蔽；`0` = 允许|
|bit7|M7|IRQ7|屏蔽 IRQ7|`1` = 屏蔽；`0` = 允许|


- **OCW1 写入端口**：主片写入 `0x21`，从片写入 `0xA1`（对应 8259A 的 IMR）。
    
- **作用范围**：OCW1/IMR 控制的是 **硬件层面的屏蔽** —— 把某条 IRQ 从被转发到 CPU 的候选中屏蔽掉。
    
- **与 CPU IF 位的交互**：IMR 只是决定“是否将该 IRQ 转发/允许”，但最终 CPU 是否响应还受 `EFLAGS.IF`（中断使能位）控制。若 `IF = 0`，即使 IMR 允许（该位为 0），CPU 也不会响应外部中断。
    
- **立即生效**：写入后立即生效，通常在初始化/驱动中按需设置屏蔽位

---

##### **OCW2**

**OCW2 用来设置中断结束方式和优先级模式**

| 位 (D#) | 字段      | 含义（作用）                                                                               |
| -----: | ------- | ------------------------------------------------------------------------------------ |
|     D7 | **R**   | Rotate（优先级轮换控制）——配合 SL/EOI 实现自动/特定轮换或设置优先级基点。                                        |
|     D6 | **SL**  | Specific Level 开关：当 `SL=1` 时，低 3 位 `L2~L0` 有效（用于指定针对哪个 IR 级别操作）；`SL=0` 时 `L2~L0` 无效。 |
|     D5 | **EOI** | End Of Interrupt 标志：`EOI=1` 表示发出（或作为）EOI 命令；`EOI=0` 时该字可用于只改变/设置优先级（视 R/SL 组合）。      |
|     D4 | -       | 保留，写入 0。                                                                             |
|     D3 | -       | 保留，写入 0。                                                                             |
|     D2 | **L2**  | 低 3 位中的高位（与 L1,L0 共同构成要作用的 IRQ/级别 0–7），仅当 `SL=1` 时有意义。                               |
|     D1 | **L1**  | 低位（二进制位）                                                                             |
|     D0 | **L0**  | 低位（二进制位）                                                                             |
![[image-6.png]]


----

##### **OCW3**
![[image-7.png]]


|位 (D#)|名称|含义|
|--:|---|---|
|D7|—（未用）|保留，写 0|
|D6|**ESMM**|Enable Special Mask Mode（使能特殊屏蔽模式的开关）|
|D5|**SMM**|Special Mask Mode（特殊屏蔽模式位，只有 ESMM=1 时有效）|
|D4|—|OCW3 标识位（高位），固定为 0|
|D3|—|OCW3 标识位（低位），固定为 1 —— `D4,D3 = 01` 表示这是 OCW3|
|D2|**P**|Poll command（查询/轮询开关）——置 1 可进入查询模式|
|D1|**RR**|Read Register（读寄存器命令使能）——置 1 才允许读取寄存器|
|D0|**RIS**|Read Interrupt register Select（选择要读的寄存器）：`0` = 读 IRR，`1` = 读 ISR|



<font size =5
color="#ff0000">如何确定写入的顺序？？</font>

|阶段|偶地址端口（主片 0x20 / 从片 0xA0）|奇地址端口（主片 0x21 / 从片 0xA1）|
|---|---|---|
|**初始化期间**|**ICW1**（第一步只能是它）|**ICW2 →（ICW3）→（ICW4）** 按顺序写|
|**初始化结束以后**|**OCW2 / OCW3**（靠字节里的标志位分辨）|**OCW1**（IMR 屏蔽寄存器）|
8259A 里有个**小状态机**，上电后它就在等“**第一步一定是 ICW1**”。

- 你往偶口（0x20/0xA0）写一个字节，它**必定按 ICW1 接收**。
    
- 接着它“知道”下一步要等 ICW2（写奇口 0x21/0xA1），如果你是级联，还会继续等 ICW3，再等 ICW4（如果 ICW1 里 IC4=1）。  
    所以初始化阶段**靠顺序识别**，根本不会把 ICW 和 OCW搞混——OCW 在初始化没完成前也**无效**。
    

---

**初始化结束后：OCW2 vs OCW3 怎么分？**

这俩都写**偶口**（0x20/0xA0），**靠字节里的第4位、第3位**来识别：

- **OCW2**：D4=0、D3=0（也就是 `..00....`）
    
- **OCW3**：D4=0、D3=1（也就是 `..01....`）
    

而 **OCW1** 很简单：初始化完成后，**只要写奇口（0x21/0xA1）** 就被当作 OCW1（IMR）。不需要再看标志位。




### 7.6 编写中断处理程序

在汇编中定义**宏**有多种方式，如果是定义单行的宏，可以用%define 指令来实现，这和 C 语言中的 define 用法一致，不多说啦。如果是定义多行的宏，就要用%macro 来实现
![[image-8.png]]
参数在哪里？哪个是第 1 个参数呢？和函数调用一样，这是由调用宏时参数传递的顺序决定的。宏调用的方式为： 宏名称以逗号分隔参数列表参数列表中最左边的参数就是第 1 个参数，参数序号并不是从 0 起的。我们在实际调用宏的时候，传入参数顺序要与宏代码体中引用的参数协调好。

**`%` 的特殊作用**: 在 NASM 宏里面，`%` 符号除了引用参数（如 `%1`），还有一个特殊功能叫做“分词”或“符号粘贴”（Token Pasting）****。当它被用在标识符（如标签名）中间时，它会将左右两边的文本和参数的值**拼接**成一个新的、单一的文本。

<font size=4 color="#ff0000">nsam -E 仅预处理并把结果输出到标准输出</font>
nasm -E input.S > output.pp

**门描述符的type字段：**

| TYPE            | 名称                        | 说明                         |
| --------------- | ------------------------- | -------------------------- |
| `0xE` (`1110b`) | **32-bit Interrupt Gate** | 进入时 **清 IF**（关中断），用 32 位偏移 |
| `0xF` (`1111b`) | **32-bit Trap Gate**      | 进入时 **不清 IF**              |
| `0x6` (`0110b`) | **16-bit Interrupt Gate** | 16 位偏移                     |
| `0x7` (`0111b`) | **16-bit Trap Gate**      | 16 位偏移                     |
| `0x5` (`0101b`) | **Task Gate**             | 通过 TSS 进行任务切换              |
