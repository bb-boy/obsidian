![[Pasted image 20250731193828.png]]makeBaseApp.pl -t ioc basic 
makeBaseApp.pl -i -t ioc basic
- **makeBaseApp.pl**：EPICS 自带的 Perl 脚本，用于生成应用开发的基本目录结构和模板文件。
- **-t ioc**：指定要创建的是 “ioc”（Input Output Controller）类型的应用模板。
- **basic**：你要创建的应用名，最后会生成一个叫 `basic` 的目录（或相关文件）。这条命令会**创建一个名为 `basic` 的 IOC 应用的基础框架**，生成 Makefile、src 目录、以及一些模板文件，方便你后续开发。
- - **-i**：表示_只生成应用实例（instance）相关的目录和文件_。  
    具体来说，它会在你的当前目录下，基于之前创建的 “basic” 应用，再生成一层实例化目录和文件。  
    你可以把它理解为“为 basic 这个 IOC 应用创建一个新实例的配置环境”。
- 其它部分和上面一样。

#### 总结一句话：

> 这条命令**只会为 `basic` 应用生成应用实例相关的目录结构和配置文件**（比如 IOC 配置、启动脚本等），而不会再生成应用代码的框架（那些文件已经由第一条命令生成了）。
![[Pasted image 20250731200842.png]]- **make**  
    是 Linux 下的自动化构建工具，会读取当前目录下的 `Makefile` 文件，按里面的规则执行任务。
    
- **clean**  
    是 `Makefile` 里的一个目标，意思是**删除所有由编译过程生成的临时文件、目标文件（.o）、可执行文件等**，让目录恢复到“未编译”状态。
    
- **uninstall**  
    也是 `Makefile` 里的目标，意思是**把之前通过 `make install` 安装到系统或指定目录的程序或库全部删除**。
make clean
make uninstall
# 1. **IOC 和客户端之间怎么通信？**

## **通信机制：Channel Access（CA）协议**

- 在 EPICS 体系里，**IOC 和客户端之间通信，主要靠 EPICS 自己的一套网络协议，叫做 Channel Access（CA）**。
- **IOC 作为服务器**，**客户端（如 `caget`、`caput`、OPI 软件）作为客户端**，通过网络来交换数据。

---

### **通信流程示意**

1. **IOC 启动后，监听一个或多个端口（通常是 5064/UDP 和 TCP）。**
    
2. **客户端（比如你在 shell 输入 `caget NUMBER`）通过网络广播或单播，去“寻找”名字叫 `NUMBER` 的 PV。**
    
3. **如果有 IOC 发布了这个 PV，客户端就可以直接跟它“对话”：**
    
    - 读（`caget`）就是请求当前值
    - 写（`caput`）就是发送新值
4. **实际通信的底层用的是标准的网络套接字（socket），数据在网络中以 EPICS CA 协议格式传递。**
    

---

### **数据交互举例**

- **`caget NUMBER` 的过程：**
    
    1. 客户端向网络发送“谁有 NUMBER 这个 PV？”
    2. IOC 收到后回应“我有！”
    3. 然后客户端与 IOC 直接建立 TCP 连接，读取变量值。
- **`caput NUMBER 123` 的过程：**
    
    1. 客户端找到发布 `NUMBER` 的 IOC
    2. 建立连接后，发送写入命令，IOC 修改其内部变量并反馈

---

# 2. **“发布”PV 是什么意思？**

## **发布的意思：**

- 当你**写好 .db 文件、st.cmd 脚本，启动 IOC 后，IOC 会把所有加载的 PV “注册/公告” 到 EPICS 网络中**。
- 这相当于告诉网络里所有 EPICS 客户端：“我这里有这些变量，谁需要可以来找我！”

## **技术细节**

- IOC 在启动时会维护一个“PV 名字—内存地址”列表
- 当客户端请求某个 PV 时，IOC 查找自己是否有这个 PV，有就响应，没有就忽略
- PV 的所有“读、写”操作都必须通过 IOC 来完成

---

# 3. **IOC 与客户端之间的关系**

- IOC 就像“广播站”，不断对外发布自己有的“频道（PV）”
- 客户端就像“收音机”，你调到某个频道（PV 名），如果广播站（IOC）在，你就能收到
- 只要 IOC 还在运行，这些 PV 就一直“在线”对外提供服务

### asyn具体流程：

1. PV `ROOM:TEMP` 定时扫描到，需要温度 → 发请求给 asyn → 马上返回
2. PV `ROOM:HUM` 需要湿度 → 也发请求给 asyn → 马上返回
3. PV `ROOM:PRES` 需要压力 → 也发请求给 asyn → 马上返回
4. asyn 线程里排队（或并发）去串口轮流访问温度计、湿度计、压力计
5. 谁先拿到数据，就“推送”回来，PV 自动刷新
`RELEASE` 文件在 EPICS 构建系统中扮演着“模块寻路器”的角色。它的主要目的是**定义 EPICS 模块、外部依赖库以及其他 EPICS 核心组件的路径**。构建系统会读取这些路径，以便在编译你的 IOC 或其他 EPICS 应用程序时知道去哪里找到所需的头文件、库文件和源文件。


初步使用Asyn模块
外部写 → record → asyn模块转发 → 你的驱动 → 设备”
外部读 → record → asyn模块要数据 → 你的驱动 → 设备，最后回传到客户端”


Ioc线程包含哪些
## **（1）主线程（Main Thread/Program Thread）**

- 作用：负责 IOC 程序的初始化、启动、管理其它线程，处理命令行（epics shell）输入，做一些管理调度。
- 举例：你启动 `basic st.cmd`，看到 `epics>` 提示符，这就是主线程的交互界面。

---

## **（2）定时扫描线程（Scan Tasks）**

- 作用：负责**周期性地扫描所有 PV（record）**，看有没有需要处理的输入/输出，比如“每秒读取一次温度”。
- EPICS 会根据不同的扫描周期（1秒、2秒、0.1秒等）创建多个 scan 线程，分别服务于不同优先级和周期的 PV。
- 举例：你有5个 PV 设置 `field(SCAN, "1 second")`，这些 PV 就由“1秒扫描线程”每隔1秒扫描一次。

---

## **（3）I/O Interrupt 线程（I/O Interrupt Threads）**

- 作用：负责处理**被硬件/驱动主动通知的“数据变更”**（比如外部硬件触发中断或者asyn驱动发来回调）。
- 举例：温度传感器主动报告温度变化，而不是 IOC 定期去“轮询”，这个“主动推送”事件就由 I/O Interrupt 线程响应。

---

## **（4）驱动/外部库线程（Driver/Asyn Threads）**

- 作用：当你用 asyn、streamDevice 或某些设备库时，会有**专门的线程负责和底层硬件通讯**（如串口、Modbus、TCP/IP等）。
- 这些线程维护自己的队列、定时器、状态机，把慢操作“异步”托管，不阻塞主线程。
- 举例：asyn 创建的串口通讯线程，负责和实际的串口设备对话，IOC 只管发请求，不等待结果。

---

## **（5）事件/消息处理线程（Event Tasks）**

- 作用：响应外部或内部的“事件”——比如软件触发的 PV 更新、报警、联动等。
- 举例：当某个 PV 值越限时，发出报警消息，event 线程负责通知相关系统。

---

## **（6）数据库维护线程（Database Maintenance Thread）**

- 作用：管理 record 的状态变更、数据同步、后台清理等。
- 举例：数据库垃圾回收、定时刷新某些缓存值。

---

## **（7）网络通信线程（Channel Access Threads）**

- 作用：负责通过网络接收客户端请求（如 caget、caput），处理 CA 协议包，返回数据。
- 举例：有客户端用 `caget` 读 PV，CA 线程负责接收请求、查找 PV、打包发送返回结果。